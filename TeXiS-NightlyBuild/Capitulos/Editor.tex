%---------------------------------------------------------------------
%
%                          Editor
%
%---------------------------------------------------------------------

\chapter{Editor}

%------------------------------------------------ IMGUI --------------------------------------------

\section{ImGUI}

ImGui es una biblioteca de interfaz de usuario (UI) que se destaca por su enfoque inmediato, generando la interfaz de usuario de manera efímera 
en cada fotograma en lugar de mantener objetos de UI a largo plazo. Esto simplifica el desarrollo y es ampliamente utilizado en la creación de ventanas, 
popups, botones, campos de texto y más. ImGui es de código abierto y está disponible en varios lenguajes de programación, lo que lo hace accesible para una 
amplia gama de desarrolladores.

Además, en nuestro proyecto, hemos aprovechado la funcionalidad de docking de ImGui, que permite conectar ventanas entre sí de manera flexible. 
Esto significa que los usuarios pueden organizar y anclar ventanas según sus preferencias, lo que facilita la personalización de la interfaz de usuario del editor. 


\subsection{Ventanas y Popups}
ImGui facilita la creación de ventanas y popups de manera intuitiva y eficaz. Esto permite organizar y presentar información de manera clara y ordenada 
en la interfaz del editor. Los métodos de ImGui, como Begin(), End(), OpenPopup(), y CloseCurrentPopup(), son utilizados para gestionar ventanas y 
popups de manera dinámica.

\subsection{Selección y Dropdowns}
La biblioteca ImGui proporciona elementos interactivos como espacios con texto seleccionables y dropdowns. Los espacios con texto seleccionables permiten a 
los usuarios interactuar con información específica, mientras que los dropdowns ofrecen opciones ocultas que se despliegan cuando el usuario lo requiere, 
mejorando la experiencia de usuario y la organización de la información.

\subsection{Inputs}
Para la entrada de datos, ImGui ofrece una variedad de métodos útiles. InputText(), por ejemplo, permite a los usuarios ingresar texto en campos designados. 
Además, se pueden utilizar otros métodos como InputInt(), InputFloat(), y InputDouble() para gestionar diferentes tipos de datos de entrada.

\subsection{Recepción y Envío de Assets Entre Ventanas}
ImGui es especialmente útil para recibir y enviar activos (assets) entre ventanas del editor. Esto se logra mediante la implementación de 
ventanas de ImGui que permiten la interacción del usuario para cargar, modificar o eliminar activos. Por ejemplo, se puede utilizar ImGui para agregar
assets al explorador de archivos o para crear entidades arrastrando y soltando imágenes en la escena.

\subsection{Inicialización}
Para inicializar ImGUI con SDL hemos seguido un procedimiento específico. Primero, se debe iniciar SDL, 
que es la biblioteca Simple DirectMedia Layer utilizada para la gestión de ventanas y gráficos. Luego, se crea el contexto de ImGui utilizando
ImGui::CreateContext(). Finalmente, se configuran las conexiones con la plataforma y el renderizador utilizando las funciones correspondientes, como:

\begin{verbatim}
ImGui_ImplSDL2_InitForSDLRenderer(window, renderer);
ImGui_ImplSDLRenderer2_Init(renderer);
\end{verbatim}

Este proceso asegura que ImGui funcione de manera efectiva junto con SDL en el proyecto.


%------------------------------------------------ GESTION DE ESCENAS --------------------------------------------

\section{Gestión de Escenas}

La clase \texttt{Scene} desempeña un papel de vital importancia en el editor, ya que asume la responsabilidad de gestionar las distintas escenas disponibles. 
Cada instancia de esta clase contiene listas de objetos y superposiciones (\textit{overlays}), que serán renderizados en la ventana principal del editor. Además, 
\texttt{Scene} presenta funcionalidades clave para ejecutar operaciones esenciales. Por ejemplo, facilita la adición de entidades y superposiciones, la capacidad 
de guardar y cargar escenas desde archivos en formato JSON, así como también la gestión tanto de la interfaz de usuario como de la representación visual de los 
elementos presentes en la escena. La clase \texttt{Scene} incluye una cámara virtual que se integra en la escena y permite al usuario explorar y visualizar el entorno 
desde diferentes perspectivas.


\subsection{Renderizado de las entidades y cámara virtual}
Para renderizar la escena, la cámara virtual contiene una textura de destino (texture target) donde se renderizarán todas las entidades utilizando la biblioteca SDL.
Este proceso tiene en cuenta la posición, tamaño y nivel de zoom de la cámara virtual. Una vez que todas las entidades se han renderizado en esta textura, se utiliza 
una ventana de ImGUI para renderizar esa textura target y mostrar la escena completa en la ventana principal del editor. Esto proporciona una representación visual 
precisa de la escena, permitiendo al usuario ver todos los elementos presentes en la misma.

Es importante destacar que las entidades y las superposiciones (overlays) no se manejan de la misma manera en el proceso de renderizado, como se habla en  (REFERENCIA).

\subsection{Métodos relevantes de la clase \texttt{Scene}}

\begin{itemize}
    \item \texttt{AddEntity()}: Este método permite añadir una nueva entidad a la lista de objetos de la escena. Las entidades representan elementos visuales 
    u objetos interactivos presentes en la escena. \texttt{AddEntity()} tiene dos versiones, una que recibe la propia entidad ya creada y otra que la construye a partir de 
    la ruta de una imagen.
    
    \item \texttt{AddOverlay()}: Similar al método anterior, \texttt{AddOverlay()} agrega elemententos de la interfaz a la lista de superposiciones de la 
    escena. Las superposiciones son elementos que se muestran por encima de las entidades y pueden contener información adicional. 
    \texttt{AddOverlay()} tiene dos versiones, una que recibe la propia entidad ya creada y otra que la construye a partir de la ruta de una imagen.
    
    \item \texttt{SaveScene()}: El método \texttt{SaveScene()} cumple con la tarea de llevar a cabo la serialización integral de la información de 
    la escena y sus entidades asociadas en un archivo \texttt{".scene"} en formato JSON. Esto garantiza la preservación y almacenamiento de la configuración completa de 
    la escena, incluyendo tanto los detalles de la propia escena como las propiedades de sus entidades. Esta información podrá ser recuperada en el futuro 
    de manera precisa y coherente en el método \texttt{LoadScene()}.

    \item \texttt{LoadScene()}: Mediante \texttt{LoadScene()}, es posible cargar una escena previamente guardada en un archivo \texttt{".scene"}. Esta función reconstruye 
    la estructura de la escena y de sus entidades a partir de los datos almacenados en el archivo.
    
    \item \texttt{RenderUI()}: Esta función tiene la responsabilidad de renderizar la interfaz de usuario (UI) asociada a la escena, incluyendo los 
    overlays mencionados previamente. Es importante destacar que renderizar elementos de Overlay difiere de renderizar objetos con transform, una similitud 
    que aquellos familiarizados con plataformas como Unity podrían encontrar. Mientras que los objetos con transform representan entidades en la escena 
    con atributos de posición, orientación  y escala, los overlays son elementos de interfaz que se superponen en la escena, proporcionando información 
    contextual o funcionalidades adicionales sin afectar directamente la posición o estructura de los objetos en la escena tridimensional.
    
    \item \texttt{RenderEntities()}: El método \texttt{RenderEntities()} desempeña la función específica de renderizar las entidades que poseen transform 
    en la escena, presentándolas visualmente en la ventana principal del editor. Mientras \texttt{RenderUI()} se enfoca en la interfaz de usuario 
    y superposiciones, \texttt{RenderEntities()} se centra únicamente en la visualización de las entidades con atributos con \texttt{transform}.
    
    \item \texttt{HandleInput()}: La función \texttt{HandleInput()} desempeña un papel crucial al gestionar las entradas del usuario, que comprenden 
    acciones como clics de ratón y pulsaciones de teclas. A través de esta función, el usuario tiene la capacidad de interactuar con la escena y sus componentes. 
    Además de permitir la selección y manipulación de entidades, este método también cumple un rol esencial en el control de la cámara. Mediante la interpretación 
    de las entradas, es posible ajustar la vista de la cámara, realizar movimientos y, en definitiva, modificar la perspectiva con la cual se visualiza 
    la escena.
    
    \item \texttt{Behaviour()}: La función \texttt{Behaviour()} orquesta el funcionamiento general de la escena en el editor. Esto incluye la ejecución de 
    la interfaz de usuario, la representación visual de las entidades y superposiciones, y la respuesta a las interacciones del usuario.
    
\end{itemize}

En conjunto, estos métodos permiten que la clase \texttt{Scene} desempeñe una función esencial en la creación y manipulación de escenas dentro del 
editor, garantizando una experiencia interactiva y eficiente para los usuarios.

%------------------------------------------------ GESTION DE VENTANAS --------------------------------------------

\section{Gestión de Ventanas}
Las ventanas en nuestro editor se gestionan a través de un vector de la clase Window que se encuentra dentro de la clase Editor. El editor tiene la responsabilidad 
de renderizar y manejar la entrada (input) de estas ventanas de manera centralizada. 

La clase Window sirve como la clase base para cada ventana en el editor, y todas las ventanas heredan de ella. Esta clase base proporciona funcionalidades 
comunes para todas las ventanas. Algunos de los métodos relevantes incluyen:

\begin{itemize}
    \item `IsFocused()`: Este método permite verificar si la ventana está enfocada o activa, lo que puede ser útil para determinar la interacción del usuario.
    
    \item `IsDocked()`: Verifica si la ventana está acoplada a otra ventana o se encuentra en modo flotante, lo que puede afectar su diseño y ubicación.
    
    \item `ReceiveAssetDrop()`: Gestiona la recepción de activos que se arrastran y sueltan en la ventana, permitiendo la incorporación de recursos 
    a la ventana de manera eficiente.

    \item `GetPosition()`: Obtiene la posición actual de la ventana.
    
    \item `SetPosition()`: Establece la posición de la ventana.
    
    \item `GetSize()`: Obtiene el tamaño actual de la ventana.
    
    \item `SetSize()`: Establece el tamaño de la ventana.
    
    \item `Hide()` y `Show()`: Controlan la visibilidad de la ventana, lo que puede ser útil para mostrar u ocultar paneles según las necesidades del usuario.
    
    \item `IsMouseHoveringWindow()`: Determina si el cursor del mouse se encuentra sobre la ventana en ese momento, lo que puede ser relevante para eventos de interacción.
    
    \item `HandleInput()`: Se encarga de gestionar la entrada de usuario, lo que incluye la capacidad de responder a eventos como clics de ratón y pulsaciones de teclas.
    
    \item `Behaviour()`: Este método se encarga de inicializar la ventana y establecer su tamaño utilizando las funciones de ImGui, como `ImGui::Begin()`, 
    `ImGui::End()`, `ImGui::SetNextWindowSize()`, y `ImGui::SetNextWindowPos()`. En medio de este método, se llama a `Behaviour()`, que define el comportamiento 
    específico de cada ventana que hereda de la clase `Window`. Por ejemplo, las ventanas de jerarquía (`Hierarchy`) o componentes (`Components`) tendrán sus 
    propios comportamientos personalizados para interactuar con el usuario de manera adecuada.

\end{itemize}

Esta estructura permite una gestión flexible y coherente de las ventanas en el editor, lo que facilita la creación de una interfaz de usuario rica y eficiente.


%------------------------------------------------ LA CLASE EDITOR Y WINDOWLAYOUT --------------------------------------------


\section{La clase Editor y WindowLayout}

\subsection{La Clase Editor y sus Estados}

La clase `Editor` desempeña un papel fundamental en la estructura de nuestro proyecto. Esta clase centraliza la gestión de las ventanas y su estado en el editor. 
Una característica destacada es la presencia de una pila de estados, que permite alternar entre dos estados principales: la ventana de scripting y el propio 
entorno del editor. Esta funcionalidad proporciona una forma eficaz de cambiar el contexto de trabajo y facilita la programación y el diseño visual en el editor.

El `Editor` también incluye métodos cruciales para guardar y cargar el estado de las distintas ventanas, determinando si están visibles o no. Los métodos 
`StoreWindowsData` y `LoadWindowsData` permiten mantener la configuración de la interfaz de usuario persistente entre sesiones del editor.

\subsection{Window Layout y su utilidad}

El proceso de renderizado de las ventanas en el editor se beneficia de la clase `Window Layout`. Esta clase juega un papel importante al administrar diferentes diseños (layouts) de ventanas. Los diseños se gestionan utilizando `ImGui::Dockbuilder`, lo que permite una organización flexible de las ventanas en el espacio de trabajo.

Los métodos de `Window Layout`, como `Update()` y `GetAllLayouts()`, facilitan la gestión y selección de diseños específicos para las ventanas. Cuando el usuario selecciona un diseño, este se aplica automáticamente al renderizar, lo que permite una experiencia de usuario personalizada y adaptable según las necesidades de cada tarea en el editor. La capacidad de cambiar rápidamente entre diseños de ventanas mejora la eficiencia y la comodidad en el flujo de trabajo del usuario.


%------------------------------------------------ FILE EXPLORER--------------------------------------------

\section{Navegación y gestión de archivos con FileExplorer}

La clase FileExplorer desempeña un papel crucial en nuestro editor al gestionar la ventana del explorador de archivos. Esta clase se encarga de controlar 
y mostrar el contenido de los directorios, así como de interactuar con los archivos y directorios presentes en el sistema de archivos del proyecto.

FileExplorer utiliza una variable auxiliar llamada Entry para almacenar información detallada sobre un archivo o directorio, incluyendo su ruta, 
nombre y extensión. Además, mantiene una cola de ficheros que representan el contenido del directorio actual. Esta cola se actualiza dinámicamente al 
cambiar de directorio o al activar la función de actualización (refresh) para reflejar el contenido más reciente.

Para navegar por los directorios y obtener información sobre ellos, FileExplorer hace uso de la biblioteca filesystem, que proporciona acceso a las 
clases path y directory iterator para la manipulación de rutas y la exploración de directorios.Entre los métodos relevantes de la clase FileExplorer, se encuentran:

\begin{itemize}
    \item `ProcessPath()`: Este método se encarga de procesar la ruta del directorio actual y actualizar la cola de ficheros para reflejar su contenido. 
    Facilita la navegación y actualización del explorador de archivos.
    
    \item `DrawList()`: Controla la representación visual de la lista de archivos y directorios en la ventana del explorador. Este método se encarga de 
    mostrar el contenido de manera legible y accesible para el usuario.
    
    \item `OnItemSelected()`: Establece las acciones a realizar al seleccionar un elemento en la lista. Además, define comportamientos específicos para las 
    extensiones de archivo, como `.scene` o `.script`, cuando se realiza doble clic sobre ellos, lo que facilita la interacción y edición de archivos relevantes
    en el proyecto.
\end{itemize}

La clase `FileExplorer` mejora la eficiencia y la comodidad del flujo de trabajo del usuario al proporcionar una interfaz intuitiva para la navegación y 
gestión de archivos y directorios en el proyecto del editor.


%------------------------------------------------ PASO DE ASSETS ENTRE ESCENAS --------------------------------------------

\section{Paso de Assets entre escenas}

Una funcionalidad esencial de nuestro editor es la capacidad de transferir activos (assets) entre escenas de manera eficiente. Para lograr esto, 
hacemos uso de las capacidades de arrastrar y soltar (drag-and-drop) proporcionadas por ImGui, específicamente a través de las funciones `BeginDragAndDropSource`,
 `SetDragDropPayload`, y BeginDragAndDropTarget.
 
Hemos desarrollado una clase auxiliar llamada `Asset` que desempeña un papel crucial en este proceso. La clase `Asset` contiene información detallada sobre un activo, 
incluyendo su nombre, extensión, ruta, ruta relativa, indicador de si es un prefab y su identificador de prefab. Esta información es esencial para garantizar que
los activos se transfieran de manera precisa y coherente entre las escenas.

Además, cada ventana en el editor, como parte de la clase `Window`, implementa el método `ReceiveAssetDrop`. Este método es responsable de procesar un activo 
recibido, y cada ventana puede personalizar su propia lógica para manejar activos específicos según sus necesidades. Por ejemplo, una ventana de 
escena podría procesar activos gráficos, mientras que una ventana de lógica podría manejar scripts. La capacidad de personalizar el comportamiento de la 
transferencia de activos es fundamental para adaptarse a las necesidades de cada ventana y facilitar la manipulación de activos en el proyecto.


%------------------------------------------------ ENTIDADES --------------------------------------------

\section{Entidades}

En el contexto del editor, las entidades son elementos fundamentales que componen la escena. Cada entidad se distingue por un identificador único asignado a 
ella, lo que permite una diferenciación clara entre las diversas entidades presentes. Ademas, una entindad también pueden estar asociada con una Textura, 
aunque esta asociación no es obligatoria, lo que significa que una entidad podría ser simplemente una entidad vacía. Destacar la existencia también del componente
\texttt{Image}, que permite modificar la ruta de la imagen asociada a la textura.


\subsection{Métodos relevantes de la clase \texttt{Entidad}}

\begin{itemize}
    \item \texttt{AssignId()}: El método \texttt{AssignId()} gestiona la asignación y desasignación de identificadores a las entidades. 
    Esto permite que cada entidad tenga un identificador único que la distinga de otras en la escena.
    
    \item \texttt{RenderTransform()}: Con el método \texttt{RenderTransform()}, las entidades se presentan en la pantalla, lo que implica su visualización en la 
    ventana principal del editor.
    
    \item \texttt{Update()}: El método \texttt{Update()} se encarga de actualizar ciertos atributos de la entidad en cada frame. Esta función es esencial para 
    mantener la coherencia y la actualización constante de las propiedades de las entidades durante la ejecución del editor.
    
    \item \texttt{HandleInput()}: \texttt{HandleInput()} permite a las entidades responder a las entradas del usuario, como clics de ratón y pulsaciones de teclas. 
 
    \item \texttt{AddComponent()}: \texttt{AddComponent()} posibilita la adición de componentes a la entidad. Los componentes son módulos que agregan funcionalidad a 
    la entidad, como algún Collider o Animación, entre otras. 
    
    \item \texttt{AddScript()}: De manera similar a \texttt{AddComponent()}, \texttt{AddScript()} permite agregar scripts a la entidad. Los scripts son fragmentos de 
    código que definen comportamientos específicos para la entidad. En el caso de nuestro editor, dichos scripts se generan automaticamente a través de nodos visuales.
    Estos nodos proporcionan una interfaz visual para crear comportamientos y lógica sin necesidad de escribir código directamente.    

    \item \texttt{SetComponents()}: \texttt{SetComponents()} se utiliza para establecer la lista de componentes asociados a la entidad. Util a la hora de crear una entidad 
    copia de un \texttt{Prefab}
    
    \item \texttt{SetScripts()}: Con \texttt{SetScripts()}, es posible definir los scripts que se aplicarán a la entidad. Util a la hora de crear una entidad 
    copia de un \texttt{Prefab}
    
    \item \texttt{ToDelete()}: Mediante \texttt{ToDelete()}, se marca la entidad para su eliminación posterior. Este método permite gestionar la eliminación de 
    entidades de manera controlada.
    
    \item \texttt{IsTransform()}: \texttt{IsTransform()} se emplea para determinar si una entidad es de tipo transform (con atributos de posición, escala y rotación) o 
    si se trata de un overlay. Esto permite una diferenciación en el manejo de las entidades según su naturaleza.

\end{itemize}

Estos métodos, en conjunto, definen la funcionalidad y el comportamiento de las entidades en el editor, permitiendo su manipulación, renderizado y 
gestión de manera efectiva y coherente.



%------------------------------------------------ JERARQUÍA --------------------------------------------


\section{Jerarquía en las escenas}

En el entorno del editor, la organización jerárquica de los elementos es una característica fundamental que permite una gestión coherente y eficiente de las entidades 
presentes en la escena. La clase \texttt{Entidad} se convierte en un componente clave para establecer esta jerarquía, ya que cada instancia incluye punteros tanto a su 
entidad padre como a una lista de entidades hijas. 

La jerarquía de entidades también se refleja en la gestión de los transform. Si una entidad tiene un padre, estos valores locales se vuelven relativos al 
padre, lo que garantiza que los movimientos y ajustes de transformación sean coherentes respecto a la jerarquía.

Para gestionar estos aspectos, la clase \texttt{Transform} se encarga de proporcionar métodos para obtener y establecer tanto los valores globales como los 
relativos.

\subsection{Métodos relevantes de la clase \texttt{Entidad} para la gestión de la jerarquía}

\begin{itemize}
    \item \texttt{AddChild()}: permite agregar una entidad como hijo de la entidad actual, estableciendo así una relación jerárquica entre ambas.
    
    \item \texttt{RemoveChild()}: permite eliminar una entidad de la lista de hijos de la entidad actual, rompiendo la relación 
    jerárquica.
    
    \item \texttt{SetParent()}: se encarga de establecer la entidad padre de la entidad actual, ajustando sus valores locales de 
    transformación de acuerdo con la jerarquía. También es posible llamar al método con \textit{nullptr} establecer que la entidad carece de padre.
    
\end{itemize}

\subsection{Métodos relevantes de la clase \texttt{Transform} para la gestión de la jerarquía}

\begin{itemize}
    \item \texttt{GetWorldPosition()}: se obtiene la posición global de la entidad, considerando la transformación jerárquica 
    en la estructura.
    \item \texttt{GetWorldScale()}: se obtiene la escala global de la entidad, considerando la estructura jerárquica.
    
    \item \texttt{GetWorldRotation()}:devuelve la rotación global de la entidad, teniendo en cuenta la jerarquía en la transformación.

    \item \texttt{SetWorldPosition()}: permite establecer la posición global de la entidad, ajustando sus valores locales y considerando 
    la jerarquía.
    
    \item \texttt{SetWorldScale()}: permite establecer la escala global de la entidad, ajustando sus valores locales y 
    respetando la jerarquía.

    \item \texttt{SetWorldRotation()}: Este método, \texttt{SetWorldRotation()}, se utiliza para establecer la rotación global de la entidad, considerando 
    la jerarquía y ajustando sus valores locales.


    \item \texttt{GetLocalPosition()}: devuelve la posición local de la entidad, que es relativa a su entidad padre en la jerarquía.
    
    \item \texttt{GetLocalScale()}: devuelve la escala local de la entidad, que se relaciona con su entidad padre en la jerarquía.

    \item \texttt{GetLocalRotation()}: devuelve la rotación local de la entidad, en relación con su entidad padre en la jerarquía.

    \item \texttt{SetLocalPosition()}: permite establecer la posición local de la entidad, considerando su entidad padre en la jerarquía.
    
    \item \texttt{SetLocalScale()}: permite establecer la escala local de la entidad, considerando su entidad padre en la jerarquía.
    
    \item \texttt{SetLocalRotation()}: permite establecer la rotación local de la entidad, considerando su entidad padre en la jerarquía.

\end{itemize}

Estos métodos, en conjunto, permiten establecer y mantener la jerarquía entre entidades y gestionar sus transformaciones de manera coherente, garantizando la organización 
precisa y eficiente de la escena en el editor. En cuanto a su visualizción, la jerarquía se representa mediante indentaciones y 
dropdowns en el editor.


%------------------------------------------------ PREFABS --------------------------------------------

\section{Prefabs y PrefabManager}

Los prefabs son copias de entidades que se guardan como plantillas para su posterior instanciación o para manejar varias instancias de un mismo prefab mientras 
se comparte una base común. Estos prefabs tienen la particularidad de que su identificador (id) es negativo, lo que los distingue de las entidades regulares. 
Esta característica les permite limitar ciertas funcionalidades, como la capacidad de referenciar otras entidades a través de scripts.

Cada entidad tiene un atributo llamado \texttt{prefabId}, el cual, en caso de ser negativo, indica que se trata de una instancia de un prefab. 
La gestión de prefabs se lleva a cabo mediante la clase \texttt{PrefabManager}, que mantiene una lista de todos los prefabs disponibles, junto con un mapa 
donde las claves son las IDs de los prefabs y los valores son vectores que contienen los ids de las entidades que son instancias de ese prefab.

\subsection{Métodos relevantes de \texttt{PrefabManager} para la gestion de prefabs}

\begin{itemize}
    \item \texttt{UpdatePrefabInstances()}: Este método se encarga de actualizar las instancias de los prefabs en 
    el escenario, asegurando su coherencia y consistencia.
    
    \item \texttt{AddPrefab()}: Permite agregar un nuevo prefab a la lista de prefabs disponibles.
    
    \item \texttt{AddInstance()}: Agrega una referencia a una instancia  de un prefab al vector correspondiente en el mapa de instancias.
    
    \item \texttt{RemoveInstance()}: Elimina la referencia a una instancia de un prefab del vector correspondiente en el mapa de instancias. Este método acepta tanto
    un puntero a la propia entidad que queremos quitar de la lista o bien dos ids, la del prefab y la de la entidad instanciada.
    
    \item \texttt{GetPrefabs()}: Devuelve la lista de todos los prefabs disponibles.
    
    \item \texttt{GetPrefabById()}: Permite obtener un prefab específico según su id.
\end{itemize}


\subsection{Métodos relevantes de la clase \texttt{Entidad} para la gestion de prefabs }

\begin{itemize}
    \item \texttt{IsPrefab()}: Indica si la entidad es un prefab (id negativo) o no.
    
    \item \texttt{IsPrefabInstance()}: Verifica si la entidad es una instancia de un prefab.
    
    \item \texttt{GetPrefabId()}: Devuelve la id del prefab al que pertenece la entidad en caso de ser una instancia de un prefab.
    
    \item \texttt{SetPrefabId()}: Establece la id de prefab para una entidad, lo que la convierte en una instancia de ese prefab.
    
    \item \texttt{GetTopParentPrefab()}: Devuelve la entidad de nivel superior dentro de la jerarquía de instancias de un mismo prefab.
\end{itemize}

La gestión de prefabs mediante la clase \texttt{PrefabManager} permite mantener un control organizado de las plantillas y sus instancias, facilitando la edición 
y manipulación coherente de la escena en el editor. Para su diferenciación visual con el resto de entidades, se dibujan de otro color dentro del editor, como vemos 
en la figura \ref{fig:instancia_prefab}.


%------------------------------------------------ COMPONENTES Y SCRIPTS --------------------------------------------
\section{Componentes}

En el contexto del sistema descrito, los componentes juegan un papel fundamental al definir el comportamiento y las propiedades de las entidades en el motor. 
Los componentes son leídos desde un archivo JSON del motor, el cual contiene información sobre cada componente, sus atributos y funciones.

La estructura de un componente se organiza en clases que facilitan su manejo y uso en el motor. Cada componente se compone de atributos y funciones que 
definen su comportamiento y propiedades. La información sobre atributos y funciones se almacena en clases específicas \texttt{Attribute} y \texttt{Function}, 
y todo esto se agrupa bajo la clase \texttt{Component}.

La clase \texttt{Entidad} desempeña un papel esencial en la gestión de componentes. Cada entidad contiene una lista de componentes que define sus características 
y comportamientos. Los componentes se serializan junto a la entidad a la que pertenecen.

\subsection{Métodos relevantes de la clase \texttt{Attribute} }

\begin{itemize}
    \item \texttt{GetValue()}: Devuelve el valor actual del atributo.
    \item \texttt{SetValue()}: Establece el valor del atributo.
    \item \texttt{GetType()}: Devuelve el tipo del atributo.
    \item \texttt{GetName()}: Devuelve el nombre del atributo.
\end{itemize}

\subsection{Métodos relevantes de la clase \texttt{Function} }

\begin{itemize}
    \item \texttt{SetReturn()}: Establece tipo de retorno de la función.
    \item \texttt{GetReturn()}: Devuelve el tipo de retorno de la función.
    \item \texttt{AddInput()}: Añade un posible input a la función.
    \item \texttt{GetName()}: Devuelve el nombre de la función.
    \item \texttt{GetComponent()}: Devuelve el nombre del componente al que pertenece la función.
\end{itemize}


\subsection{Métodos relevantes de la clase \texttt{Component} }

\begin{itemize}
    \item \texttt{GetName()}: Devuelve el nombre del componente.
    \item \texttt{GetAttribute()}: Permite obtener un atributo específico de un componente mediante su nombre. 
    \item \texttt{GetFunction()}: Permite obtener una función específica de un componente utilizando su nombre
    \item \texttt{FromJson()}: Reconstruye un componente a partir de un fragmento en formato JSON.
    \item \texttt{ToJson()}: Lleva a cabo la serialización integral de la información del componente y sus atributos y funciones 
    asociadas en un archivo en formato JSON. 
\end{itemize}


\subsection{Métodos relevantes de la clase \texttt{Entidad} para la gestión de componentes }

\begin{itemize}
    \item \texttt{AddComponent()}: Añade un componente a la entidad.
    \item \texttt{GetComponents()}: Devuelve el mapa de componentes de la entidad.
    \item \texttt{SetComponents()}: Recibe y una lista de componentes para asignarsela a la entidad.
\end{itemize}

En resumen, los componentes y su relación con las entidades en el motor permiten una estructuración eficiente y una personalización 
precisa de la funcionalidad de cada elemento en el mundo virtual, enriqueciendo la experiencia del usuario y posibilitando un proceso 
de desarrollo más fluido y adaptativo.



%------------------------------------------------ EJECUCION, CARPETAS, Y BUILD --------------------------------------------

\section{Ejecución del juego, estructura de carpetas y build del motor}

\subsection{Ejecución del juego y redirección de la salida mediante tuberías}
La ejecución del juego en nuestro editor se maneja a través de dos botones ubicados en la parte superior, que permiten ejecutar el juego en modo de 
depuración (\textit{debug}) o en modo de lanzamiento (\textit{release}). Estos botones invocan el método \texttt{play()} de la clase \texttt{Game}. 
El método \texttt{play()} se encarga de configurar una tubería para redirigir la salida del juego hacia el editor, y ser mostrado así en la consola. 
Además, inicia un hilo que se encarga de capturar y guardar los datos provenientes de esa tubería. Cuando el juego se cierra, se llama al método 
\texttt{stop()}, que cierra el hilo y finaliza el proceso del juego de manera ordenada.

\subsection{Estructura de carpetas}
En cuanto a la estructura de carpetas, en la solución del Editor se encuentra una carpeta Editor dedicada para almacenar los (\textit{assets}) y 
configuraciones necesarios para el proyecto. Dentro de esta carpeta, se encuentra otra denominada Engine que alberga los ejecutables y recursos generados a partir 
de la (\textit{build}) del motor del juego.Por otro lado, al ejecutar el editor, se creará una carpeta adicional a través del Project Manager que contendrá exclusivamente 
los recursos específicos de nuestro proyecto de videojuego.

IMAGEN

\subsection{Build del motor}
Para realizar la construcción del motor, es esencial configurar el directorio de salida en la ubicación mencionada anteriormente. Además, se requiere 
copiar los archivos Components.json y Managers.json desde la carpeta ecs/ECSUtilities hacia esta misma carpeta, asegurando que todos los recursos necesarios 
estén disponibles para el funcionamiento adecuado del motor.

En resumen, la ejecución del juego se gestiona mediante botones en el editor, con un sistema que redirige la salida y captura los datos del juego. 
La estructura de carpetas está organizada de manera que los activos y configuraciones se encuentren separados de los recursos generados por la construcción del motor, 
facilitando así la gestión del proyecto.