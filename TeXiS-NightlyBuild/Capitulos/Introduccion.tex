%---------------------------------------------------------------------
%
%                          Introduccion
%
%---------------------------------------------------------------------

\chapter{Introducción}

%-------------------------------------------------------------------
\section{Motivación}
\label{cap1:sec:motivacion}

En lo relacionado a motores de videojuegos durante el grado, en primero aprendimos las bases de Unity, en segundo
desarrollamos videojuegos 2D sencillos con SDL con una capa de abstracción para facilitar el aprendizaje y en tercero
tuvimos que salir de la zona de comfort y aprender que hay detrás de las herramientas que nos proporcionaban durante
el grado desarrollando así un motor de videojuegos 3D usando OGRE como motor gráfico, BulletPhysics como motor físico, 
FMOD como librería de sonido y Lua como lenguaje de scripting.

Con esta experiencia nos dimos cuenta de varias cosas. Es más comodo trabajar con un motor que cuenta 
con un editor integrado en vez de acceder a él directamente a través de programación. Además, la forma 
de programar los scripts, queson fragmentos de código que definen comportamientos específicos para las entidades, 
debe ser cómoda e intuible ya que es la tarea que más más tiempo va a ocupar al desarrollaor.

Por último, en cuarto y con la reciente experiencia de desarrollo de un motor decidimos que la propuesta del trabajo de fin de 
grado sería un motor con la siguientes características:

\begin{itemize}

\item \texttt{Autosuficiencia}: Esto siginifca que aporta funcionalidad para manejar recursos, crear escenas 
y objetos desde el editor y cuenta con la creación de ejecutables finales del juego para su distribución. 
Además, el motor podrá mostrar la ejecución del juego directamente en el editor durante su desarrollo. 
Obviamente no tiene toda la funcionalidad necesaria como para no depender de ninguna herrmienta externa 
durante el desarrollo pero si aporta lo básico para el ciclo de desarrollo de un videojuego 2D.

\item \texttt{Editor integrado}: La principal herramienta de un motor autosuficiente es el editor, encargado 
de comunicar al motor las accciones del desarrollador. No teníamos experiencia en desarrollo de aplicaciones 
de escritorio, ya que para el motor de tercero no hicimos editor (por lo que sabíamos que podía ser un reto).

\item \texttt{Programación visual basada en nodos}: Esta es la parte a destacar de nuestro motor. Debido a la 
complejidad que presentan algunos motores de la actualidad para desarrolladores principiantes o inexpertos, 
la programación visual es una herramienta muy útil e intuitiva para crear lógica y comportamiento en el 
videojuego. Sabíamos que podía ser desafiante a nivel técnico pero aportaría mucha comodidad, fluidez y por 
supuesto abriría las puertas de nuestro motor a muchos desarrolladores con poca experiencia en programación.

\end{itemize}

Por último, optamos por el 2D debido a la experiencia obtenida durante la carrera. Además, supone menor 
complejidad a nivel técnico durante el desarrollo del motor.

%-------------------------------------------------------------------
\section{Objetivos}
\label{cap1:sec:objetivos}

El objetivo principal del trabajo de fin de grado es desarrollar el motor de videojuegos 2D autosuficiente con editor
integrado y programación visual basada en nodos. Con esto, los usuarios dispondrán de una herramienta para desarrollar
cualquier tipo de videojuego 2D.

\medskip

Con la autosuficiencia del motor queremos conseguir que los usuarios puedan desarrollar sus videojuegos con la mínima
dependencia posible de herramientas externas de tal forma que todo el trabajo pase por el editor.

Con el editor queremos conseguir que el desarrollo sea cómodo, fluido y visual evitando así que el desarrollador se 
tenga que comnunicar con el motor vía programación.

Con el sistema de programación visual basada en nodos queremos conseguir abrir las puertas de nuestro motor a
desarrolladores inexpertos o con bajos cononcimientos en programación para que así puedan desarrollar sus videojuegos.
Además, supone un reto a nivel técnico que nos aportará experiencia y conocimiento.

%-------------------------------------------------------------------
\section{Herramientas}
\label{cap1:sec:herramientas}

Para comenzar, se ha utilizado Git como sistema de control de versiones a través de la aplicación de escritorio
GitHub Desktop. Todo el código implementado se ha subido a un repositorio dividiendo el trabajo en ramas. En concreto,
tal y como se cuenta en el plan de trabajo, el proyecto se ha dividido en motor, editor y programación visual.

Enlace al repositorio: \url{https://github.com/ivasan07/ShyEngine}

\medskip

Para el desarrollo del motor se ha hecho uso de la librería de SDL (Simple DirectMedia Layer). En concreto, se ha 
utilizado SDL Image como sistema de gráficos, SDL Mixer como sistema de audio y SDL TTF como sistema de fuentes 
TrueType para renderizar texto. También se ha utilizado la librería Box2D para la simulación física y manejo de 
colisiones 2D.

\medskip

Para el desarrollo del editor se ha hecho uso de la librería de interfaz gráfica ImGUI.

\medskip

El código ha sido desarrollado en el entorno de desarrollo integrado (IDE) Visual Studio 2022 y escrito en C++. Por 
último, para la organización de tareas hemos usado la herramienta de gestión de proyectos Trello.

%-------------------------------------------------------------------
\section{Plan de trabajo}
\label{cap1:sec:plandetrabajo}

El trabajo se divide en tres partes: el desarrollo del motor, el desarrollo del editor y el desarrollo del sistema
de scripting visual basado en nodos.

La primera fase del trabajo consistirá en el desarrollo del núcleo de cada una de las tres partes por separado: 

- Motor: Para la parte del motor esta fase consistirá en la investigación de posibles librerías a utilizar, integración y 
funcionamiento básico en el entorno de trabajo de las librerías elegidas, implementación del sistema de entidades
y componentes y desarrollo de componentes fundamentales. 

- Editor: Para la parte del editor esta fase consistirá en  en investigar librerías gráficas, con especial énfasis en aquellas adecuadas para la interfaz de usuario (UI). 
Además, incluirá la implementación de una escena navegable de carácter básico, la creación y manipulación de entidades dentro de dicha escena, así como la modificación de su \texttt{Transform}, 
seguida de la correspondiente serialización de estos elementos.

- Sistema de scripting: Para la parte del scripting esta fase consistirá en

La segunda fase del trabajo consistirá en la integración de las tres partes, posible reimplementación de funcionalidad
no compatible y continuación con el desarrollo por separado: 

- Motor: Para la parte del motor esta fase consistirá en el desarrollo del bucle principal, funcionalidad requerida para la 
comunicación motor-editor y terminar con el desarrollo de componentes y managers fundamentales.

- Editor: Para la parte del editor esta fase consistirá en la lectura de los componentes del motor, su visualización y edición, así como en la serialización y lectura de las escenas,
abordando además otros aspectos fundamentales para un editor, tales como la implementación de la ventana de jerarquía y el explorador de archivos.

- Sistema de scripting: Para la parte del scripting esta fase consistirá en 

La tercera fase del trabajo consistirá en mejorar el editor para conseguir una experiencia de usuario satisfactoria, 
desarrollar algún que otro minijuego y realizar pruebas con usuarios:

- Motor: Para la parte del motor esta fase consistirá en realizar pruebas desde el editor y sistema de scripting para 
comprobar el correcto funcionamiento de todas las partes del motor y arreglar lo necesario.

- Editor: Para la parte del editor esta fase consistirá en la implementación de una jerarquía entre entidades, la implementación de prefabs, la lectura de escenas serializadas, 
la ejecución de las escenas en el motor, así como el arreglo de fallos y la incorporación de otras mejoras destinadas a aumentar la comodidad del desarrollador. Algún ejemplo de estas 
mejoras es la capacidad de arrastrar imágenes directamente desde el sistema operativo Windows hasta el editor, la depuración de errores a través de una consola, la creación de paletas, 
y muchas otras.

- Sistema de scripting: Para la parte del scripting esta fase consistirá en 

\textbf{\textit{TODO: Fase de prueba con usuarios\ldots}}




%---------------------------------------------------------------------
%
%                          Introduccion EN
%
%---------------------------------------------------------------------

\chapter{Introduction}

%-------------------------------------------------------------------
\section{Motivation}
\label{cap2:sec:motivation}

Regarding game engines during our degree, in the first year, we learned the basics of Unity, in the second year, 
we developed simple 2D games with SDL using an abstraction layer to facilitate learning, and in the third year, 
we had to step out of our comfort zone and learn what's behind the tools provided to us during the degree. 
This led us to develop a 3D game engine using OGRE as the graphics engine, BulletPhysics as the physics engine, 
FMOD as the sound library, and Lua as the scripting language.

Through this experience, we realized several things. It's more convenient to work with an engine that has an 
integrated editor rather than accessing it directly through programming. Additionally, scripting should be 
comfortable and intuitive since it's the task that will take up the most time for the developer.

In the fourth year, with the recent experience of developing a game engine, we decided that the proposal for our
final degree project would be an engine with the following characteristics:

\begin{itemize}

\item \texttt{Self-sufficient}: This means it provides functionality to manage resources, create scenes 
and objects from the editor, and can generate final game executables for distribution. Obviously, it doesn't 
have all the necessary functionality to be completely independent of any external tools during development, 
but it does provide the basics for the development cycle of a 2D game.

\item \texttt{Integrated Editor}: The main tool of a self-sufficient engine is its editor, responsible for 
communicating the developer's actions to the engine. We had no experience in developing desktop 
applications, as we didn't create an editor for the third-year engine, so we knew it could be a challenge..

\item \texttt{Visual Node-Based Programming}: This is the highlight of our engine. Due to the complexity 
that some modern engines present for beginner or inexperienced developers, visual programming is a very 
useful and intuitive tool for creating logic and behavior in the game. We knew it could be a technical 
challenge, but it would provide great convenience, fluidity, and, of course, open the doors of our engine 
to many developers with little programming experience.

\end{itemize}

Finally, we chose to focus on 2D due to the experience gained during our studies. Additionally, it 
involves less technical complexity during the development of the engine.

%-------------------------------------------------------------------
\section{Goals}
\label{cap2:sec:goals}

The main objective of the final degree project is to develop a self-sufficient 2D game engine with an integrated 
editor and node-based visual programming. With this, users will have a tool to develop any type of 2D video game.

\medskip

By achieving self-sufficiency in the engine, we aim to enable users to develop their video games with minimal 
reliance on external tools, ensuring that all the work can be done within the editor.

With the editor, our goal is to make the development process comfortable, smooth, and visually-oriented, eliminating
the need for developers to communicate with the engine through programming.

With the node-based visual programming system, we aim to open the doors of our engine to inexperienced developers
or those with limited programming knowledge, allowing them to develop their videogames. In addition, it represents 
a technical challenge that will provide us with experience and knowledge.

%-------------------------------------------------------------------
\section{Project Management}
\label{cap2:sec:projectmanagement}

To start with, Git has been used as the version control system through the GitHub Desktop application. All the 
implemented code has been uploaded to a repository, dividing the work into branches. Specifically, as outlined 
in the work plan, the project has been divided into engine, editor, and visual programming.

Repository link: \url{https://github.com/ivasan07/ShyEngine}

\medskip

For the development of the engine, the SDL (Simple DirectMedia Layer) library has been used. In particular, 
SDL Image has been used for graphics, SDL Mixer for audio, and SDL TTF for TrueType font rendering. The Box2D 
library has also been used for 2D physics simulation and collision handling.

For the development of the editor, the ImGUI (Immediate Mode Graphical User Interface) library has been used.

\medskip

The code has been developed in the Visual Studio 2022 Integrated Development Environment (IDE) and written in C++. 
Finally, for task organization, we have used the Trello project management tool.

%-------------------------------------------------------------------
\section{Work Plan}
\label{cap2:sec:workplan}

The work is divided into three main parts: engine development, editor development, and the development of a visual node-based
scripting system.

The first phase of the work will involve the development of the core of each of the three parts separately:

- Engine: For the engine part, this phase will involve researching potential libraries to use, integrating and ensuring basic
functionality within the chosen library's working environment, implementing the entity and component system, and developing 
essential components.

- Editor: For the editor part, this phase will consist of researching graphic libraries, with special emphasis on those suitable for the user interface (UI). 
In addition, it will include the implementation of a basic navigable scene, the creation and manipulation of entities within this scene, as well as the modification of its \texttt{Transform}, 
followed by the corresponding serialization of these elements.

- Scripting System: For the scripting part, this phase will consist of...

The second phase of the work will focus on integrating the three parts, potentially reimplementing incompatible functionality, 
and continuing with separate development:

- Engine: For the engine part, this phase will involve developing the main loop, the required functionality for engine-editor 
communication, and completing the development of essential components and managers.

- Editor: For the editor part this phase will consist of reading the engine components, displaying and editing them, as well as serializing and reading the scenes,
and other fundamental aspects for an editor, such as the implementation of the hierarchy window and the file explorer.

- Scripting System: For the scripting part, this phase will consist of...

The third phase of the work will aim to improve the editor for a satisfactory user experience, develop some mini-games, and
conduct user testing:

- Engine: For the engine part, this phase will involve conducting tests from the editor and scripting system to verify the correct
functioning of all engine parts and making necessary fixes.

- Editor: For the editor part this phase will consist of the implementation of a hierarchy between entities, the implementation of prefabs, the reading of serialized scenes, 
the execution of the scenes in the engine, as well as bug fixing and the incorporation of other improvements aimed at increasing the developer's comfort. Some examples of these 
improvements are the ability to drag images directly from the Windows operating system to the editor, debugging errors through a console, palette creation, and many others, 
and many others.

- Scripting System: For the scripting part, this phase will consist of...


\textbf{\textit{TODO: Fase de prueba con usuarios\ldots}}




% %-------------------------------------------------------------------
% \section*{\NotasBibliograficas}
% %-------------------------------------------------------------------
% \TocNotasBibliograficas

% Citamos algo para que aparezca en la bibliografía\ldots
% \citep{ldesc2e}

% \medskip

% Y también ponemos el acrónimo \ac{CVS} para que no cruja.

% Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras
% no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
