%---------------------------------------------------------------------
%
%                          Implementacion
%
%---------------------------------------------------------------------

\chapter{Implementación}

%-------------------------------------------------------------------
\section{Editor}
%-------------------------------------------------------------------
\label{cap4:sec:editor}

%------------------------------------------------ GESTION DE ESCENAS --------------------------------------------

\subsection{Gestión de Escenas}

La clase \texttt{Scene} desempeña un papel de vital importancia en el editor, ya que asume la responsabilidad de gestionar las distintas escenas disponibles. 
Cada instancia de esta clase contiene listas de objetos y superposiciones (\textit{overlays}), que serán renderizados en la ventana principal del editor. Además, 
\texttt{Scene} presenta funcionalidades clave para ejecutar operaciones esenciales. Por ejemplo, facilita la adición de entidades y superposiciones, la capacidad 
de guardar y cargar escenas desde archivos en formato JSON, así como también la gestión tanto de la interfaz de usuario como de la representación visual de los 
elementos presentes en la escena. La clase \texttt{Scene} incluye una cámara virtual que se integra en la escena y permite al usuario explorar y visualizar el entorno 
desde diferentes perspectivas.

\subsubsection{Métodos relevantes de la clase \texttt{Scene}}

\begin{itemize}
    \item \texttt{AddEntity()}: Este método permite añadir una nueva entidad a la lista de objetos de la escena. Las entidades representan elementos visuales 
    u objetos interactivos presentes en la escena. \texttt{AddEntity()} tiene dos versiones, una que recibe la propia entidad ya creada y otra que la construye a partir de 
    la ruta de una imagen.
    
    \item \texttt{AddOverlay()}: Similar al método anterior, \texttt{AddOverlay()} agrega elemententos de la interfaz a la lista de superposiciones de la 
    escena. Las superposiciones son elementos que se muestran por encima de las entidades y pueden contener información adicional. 
    \texttt{AddOverlay()} tiene dos versiones, una que recibe la propia entidad ya creada y otra que la construye a partir de la ruta de una imagen.
    
    \item \texttt{SaveScene()}: El método \texttt{SaveScene()} cumple con la tarea de llevar a cabo la serialización integral de la información de 
    la escena y sus entidades asociadas en un archivo \texttt{".scene"} en formato JSON. Esto garantiza la preservación y almacenamiento de la configuración completa de 
    la escena, incluyendo tanto los detalles de la propia escena como las propiedades de sus entidades. Esta información podrá ser recuperada en el futuro 
    de manera precisa y coherente en el método \texttt{LoadScene()}.

    \item \texttt{LoadScene()}: Mediante \texttt{LoadScene()}, es posible cargar una escena previamente guardada en un archivo \texttt{".scene"}. Esta función reconstruye 
    la estructura de la escena y de sus entidades a partir de los datos almacenados en el archivo.
    
    \item \texttt{RenderUI()}: Esta función tiene la responsabilidad de renderizar la interfaz de usuario (UI) asociada a la escena, incluyendo los 
    overlays mencionados previamente. Es importante destacar que renderizar elementos de Overlay difiere de renderizar objetos con transform, una similitud 
    que aquellos familiarizados con plataformas como Unity podrían encontrar. Mientras que los objetos con transform representan entidades en la escena 
    con atributos de posición, orientación  y escala, los overlays son elementos de interfaz que se superponen en la escena, proporcionando información 
    contextual o funcionalidades adicionales sin afectar directamente la posición o estructura de los objetos en la escena tridimensional.
    
    \item \texttt{RenderEntities()}: El método \texttt{RenderEntities()} desempeña la función específica de renderizar las entidades que poseen transform 
    en la escena, presentándolas visualmente en la ventana principal del editor. Mientras \texttt{RenderUI()} se enfoca en la interfaz de usuario 
    y superposiciones, \texttt{RenderEntities()} se centra únicamente en la visualización de las entidades con atributos con \texttt{transform}.
    
    \item \texttt{HandleInput()}: La función \texttt{HandleInput()} desempeña un papel crucial al gestionar las entradas del usuario, que comprenden 
    acciones como clics de ratón y pulsaciones de teclas. A través de esta función, el usuario tiene la capacidad de interactuar con la escena y sus componentes. 
    Además de permitir la selección y manipulación de entidades, este método también cumple un rol esencial en el control de la cámara. Mediante la interpretación 
    de las entradas, es posible ajustar la vista de la cámara, realizar movimientos y, en definitiva, modificar la perspectiva con la cual se visualiza 
    la escena.
    
    \item \texttt{Behaviour()}: La función \texttt{Behaviour()} orquesta el funcionamiento general de la escena en el editor. Esto incluye la ejecución de 
    la interfaz de usuario, la representación visual de las entidades y superposiciones, y la respuesta a las interacciones del usuario.
    
\end{itemize}

En conjunto, estos métodos permiten que la clase \texttt{Scene} desempeñe una función esencial en la creación y manipulación de escenas dentro del 
editor, garantizando una experiencia interactiva y eficiente para los usuarios.

\medskip

\textbf{\textit{TODO: Mostrar imagenes de las distintas escenas ¿?\ldots}}

%------------------------------------------------ ENTIDADES --------------------------------------------

\subsection{Entidades}

En el contexto del editor, las entidades son elementos fundamentales que componen la escena. Cada entidad se distingue por un identificador único asignado a 
ella, lo que permite una diferenciación clara entre las diversas entidades presentes. Ademas, una entindad también pueden estar asociada con una Textura, 
aunque esta asociación no es obligatoria, lo que significa que una entidad podría ser simplemente una entidad vacía. Destacar la existencia también del componente
\texttt{Image}, que permite modificar la ruta de la imagen asociada a la textura.


\subsubsection{Métodos relevantes de la clase \texttt{Entidad}}

\begin{itemize}
    \item \texttt{AssignId()}: El método \texttt{AssignId()} gestiona la asignación y desasignación de identificadores a las entidades. 
    Esto permite que cada entidad tenga un identificador único que la distinga de otras en la escena.
    
    \item \texttt{RenderTransform()}: Con el método \texttt{RenderTransform()}, las entidades se presentan en la pantalla, lo que implica su visualización en la 
    ventana principal del editor.
    
    \item \texttt{Update()}: El método \texttt{Update()} se encarga de actualizar ciertos atributos de la entidad en cada frame. Esta función es esencial para 
    mantener la coherencia y la actualización constante de las propiedades de las entidades durante la ejecución del editor.
    
    \item \texttt{HandleInput()}: \texttt{HandleInput()} permite a las entidades responder a las entradas del usuario, como clics de ratón y pulsaciones de teclas. 
 
    \item \texttt{AddComponent()}: \texttt{AddComponent()} posibilita la adición de componentes a la entidad. Los componentes son módulos que agregan funcionalidad a 
    la entidad, como algún Collider o Animación, entre otras. 
    
    \item \texttt{AddScript()}: De manera similar a \texttt{AddComponent()}, \texttt{AddScript()} permite agregar scripts a la entidad. Los scripts son fragmentos de 
    código que definen comportamientos específicos para la entidad. En el caso de nuestro editor, dichos scripts se generan automaticamente a través de nodos visuales.
    Estos nodos proporcionan una interfaz visual para crear comportamientos y lógica sin necesidad de escribir código directamente.    

    \item \texttt{SetComponents()}: \texttt{SetComponents()} se utiliza para establecer la lista de componentes asociados a la entidad. Util a la hora de crear una entidad 
    copia de un \texttt{Prefab}
    
    \item \texttt{SetScripts()}: Con \texttt{SetScripts()}, es posible definir los scripts que se aplicarán a la entidad. Util a la hora de crear una entidad 
    copia de un \texttt{Prefab}
    
    \item \texttt{ToDelete()}: Mediante \texttt{ToDelete()}, se marca la entidad para su eliminación posterior. Este método permite gestionar la eliminación de 
    entidades de manera controlada.
    
    \item \texttt{IsTransform()}: \texttt{IsTransform()} se emplea para determinar si una entidad es de tipo transform (con atributos de posición, escala y rotación) o 
    si se trata de un overlay. Esto permite una diferenciación en el manejo de las entidades según su naturaleza.

\end{itemize}

Estos métodos, en conjunto, definen la funcionalidad y el comportamiento de las entidades en el editor, permitiendo su manipulación, renderizado y 
gestión de manera efectiva y coherente.



%------------------------------------------------ JERARQUÍA --------------------------------------------


\subsection{Jerarquía en las escenas}

En el entorno del editor, la organización jerárquica de los elementos es una característica fundamental que permite una gestión coherente y eficiente de las entidades 
presentes en la escena. La clase \texttt{Entidad} se convierte en un componente clave para establecer esta jerarquía, ya que cada instancia incluye punteros tanto a su 
entidad padre como a una lista de entidades hijas. 

La jerarquía de entidades también se refleja en la gestión de los transform. Si una entidad tiene un padre, estos valores locales se vuelven relativos al 
padre, lo que garantiza que los movimientos y ajustes de transformación sean coherentes respecto a la jerarquía.

Para gestionar estos aspectos, la clase \texttt{Transform} se encarga de proporcionar métodos para obtener y establecer tanto los valores globales como los 
relativos.

\subsubsection{Métodos relevantes de la clase \texttt{Entidad} para la gestión de la jerarquía}

\begin{itemize}
    \item \texttt{AddChild()}: Este método permite agregar una entidad como hijo de la entidad actual, estableciendo así una relación jerárquica entre ambas.
    
    \item \texttt{RemoveChild()}: Usando \texttt{RemoveChild()}, es posible eliminar una entidad de la lista de hijos de la entidad actual, rompiendo la relación 
    jerárquica.
    
    \item \texttt{SetParent()}: El método \texttt{SetParent()} se encarga de establecer la entidad padre de la entidad actual, ajustando sus valores locales de 
    transformación de acuerdo con la jerarquía. También es posible llamar al método con \textit{nullptr} establecer que la entidad carece de padre.
    
\end{itemize}

\subsubsection{Métodos relevantes de la clase \texttt{Transform} para la gestión de la jerarquía}

\begin{itemize}
    \item \texttt{GetWorldPosition()}: Con \texttt{GetWorldPosition()}, se obtiene la posición global de la entidad, considerando la transformación jerárquica 
    en la estructura.
    \item \texttt{GetWorldScale()}: Al utilizar \texttt{GetWorldScale()}, se obtiene la escala global de la entidad, considerando la estructura jerárquica.
    
    \item \texttt{GetWorldRotation()}: \texttt{GetWorldRotation()} devuelve la rotación global de la entidad, teniendo en cuenta la jerarquía en la transformación.

    \item \texttt{SetWorldPosition()}: \texttt{SetWorldPosition()} permite establecer la posición global de la entidad, ajustando sus valores locales y considerando 
    la jerarquía.
    
    \item \texttt{SetWorldScale()}: Con \texttt{SetWorldScale()}, es posible establecer la escala global de la entidad, ajustando sus valores locales y 
    respetando la jerarquía.

    \item \texttt{SetWorldRotation()}: Este método, \texttt{SetWorldRotation()}, se utiliza para establecer la rotación global de la entidad, considerando 
    la jerarquía y ajustando sus valores locales.


    \item \texttt{GetLocalPosition()}: \texttt{GetLocalPosition()} devuelve la posición local de la entidad, que es relativa a su entidad padre en la jerarquía.
    
    \item \texttt{GetLocalScale()}: \texttt{GetLocalScale()} devuelve la escala local de la entidad, que se relaciona con su entidad padre en la jerarquía.

    \item \texttt{GetLocalRotation()}: \texttt{GetLocalRotation()} devuelve la rotación local de la entidad, en relación con su entidad padre en la jerarquía.

    \item \texttt{SetLocalPosition()}: \texttt{SetLocalPosition()} permite establecer la posición local de la entidad, considerando su entidad padre en la jerarquía.
    
    \item \texttt{SetLocalScale()}: \texttt{SetLocalScale()} permite establecer la escala local de la entidad, considerando su entidad padre en la jerarquía.
    
    \item \texttt{SetLocalRotation()}: \texttt{SetLocalRotation()} permite establecer la rotación local de la entidad, considerando su entidad padre en la jerarquía.

\end{itemize}

Estos métodos, en conjunto, permiten establecer y mantener la jerarquía entre entidades y gestionar sus transformaciones de manera coherente, garantizando la organización 
precisa y eficiente de la escena en el editor. En cuanto a su visualizción, la jerarquía se representa mediante indentaciones y 
dropdowns en el editor. \ref{fig:instancia_prefab}



%------------------------------------------------ PREFABS --------------------------------------------

\subsection{Prefabs y PrefabManager}

Los prefabs son copias de entidades que se guardan como plantillas para su posterior instanciación o para manejar varias instancias de un mismo prefab mientras 
se comparte una base común. Estos prefabs tienen la particularidad de que su identificador (id) es negativo, lo que los distingue de las entidades regulares. 
Esta característica les permite limitar ciertas funcionalidades, como la capacidad de referenciar otras entidades a través de scripts.

Cada entidad tiene un atributo llamado \texttt{prefabId}, el cual, en caso de ser negativo, indica que se trata de una instancia de un prefab. 
La gestión de prefabs se lleva a cabo mediante la clase \texttt{PrefabManager}, que mantiene una lista de todos los prefabs disponibles, junto con un mapa 
donde las claves son las IDs de los prefabs y los valores son vectores que contienen los ids de las entidades que son instancias de ese prefab.

\subsubsection{Métodos relevantes de \texttt{PrefabManager} para la gestion de prefabs}

\begin{itemize}
    \item \texttt{UpdatePrefabInstances()}: Este método se encarga de actualizar las instancias de los prefabs en 
    el escenario, asegurando su coherencia y consistencia.
    
    \item \texttt{AddPrefab()}: Permite agregar un nuevo prefab a la lista de prefabs disponibles.
    
    \item \texttt{AddInstance()}: Agrega una referencia a una instancia  de un prefab al vector correspondiente en el mapa de instancias.
    
    \item \texttt{RemoveInstance()}: Elimina la referencia a una instancia de un prefab del vector correspondiente en el mapa de instancias. Este método acepta tanto
    un puntero a la propia entidad que queremos quitar de la lista o bien dos ids, la del prefab y la de la entidad instanciada.
    
    \item \texttt{GetPrefabs()}: Devuelve la lista de todos los prefabs disponibles.
    
    \item \texttt{GetPrefabById()}: Permite obtener un prefab específico según su id.
\end{itemize}


\subsubsection{Métodos relevantes de la clase \texttt{Entidad} para la gestion de prefabs }

\begin{itemize}
    \item \texttt{IsPrefab()}: Indica si la entidad es un prefab (id negativo) o no.
    
    \item \texttt{IsPrefabInstance()}: Verifica si la entidad es una instancia de un prefab.
    
    \item \texttt{GetPrefabId()}: Devuelve la id del prefab al que pertenece la entidad en caso de ser una instancia de un prefab.
    
    \item \texttt{SetPrefabId()}: Establece la id de prefab para una entidad, lo que la convierte en una instancia de ese prefab.
    
    \item \texttt{GetTopParentPrefab()}: Devuelve la entidad de nivel superior dentro de la jerarquía de instancias de un mismo prefab.
\end{itemize}

La gestión de prefabs mediante la clase \texttt{PrefabManager} permite mantener un control organizado de las plantillas y sus instancias, facilitando la edición 
y manipulación coherente de la escena en el editor. Para su diferenciación visual con el resto de entidades, se dibujan de otro color dentro del editor, como vemos 
en la figura \ref{fig:instancia_prefab}.



%------------------------------------------------ COMPONENTES Y SCRIPTS --------------------------------------------
\subsection{Componentes}

En el contexto del sistema descrito, los componentes juegan un papel fundamental al definir el comportamiento y las propiedades de las entidades en el motor. 
Los componentes son leídos desde un archivo JSON del motor, el cual contiene información sobre cada componente, sus atributos y funciones.

La estructura de un componente se organiza en clases que facilitan su manejo y uso en el motor. Cada componente se compone de atributos y funciones que 
definen su comportamiento y propiedades. La información sobre atributos y funciones se almacena en clases específicas \texttt{Attribute} y \texttt{Function}, 
y todo esto se agrupa bajo la clase \texttt{Component}.

La clase \texttt{Entidad} desempeña un papel esencial en la gestión de componentes. Cada entidad contiene una lista de componentes que define sus características 
y comportamientos. Los componentes se serializan junto a la entidad a la que pertenecen.

\subsubsection{Métodos relevantes de la clase \texttt{Attribute} }

\begin{itemize}
    \item \texttt{GetValue()}: Devuelve el valor actual del atributo.
    \item \texttt{SetValue()}: Establece el valor del atributo.
    \item \texttt{GetType()}: Devuelve el tipo del atributo.
    \item \texttt{GetName()}: Devuelve el nombre del atributo.
\end{itemize}

\subsubsection{Métodos relevantes de la clase \texttt{Function} }

\begin{itemize}
    \item \texttt{SetReturn()}: Establece tipo de retorno de la función.
    \item \texttt{GetReturn()}: Devuelve el tipo de retorno de la función.
    \item \texttt{AddInput()}: Añade un posible input a la función.
    \item \texttt{GetName()}: Devuelve el nombre de la función.
    \item \texttt{GetComponent()}: Devuelve el nombre del componente al que pertenece la función.
\end{itemize}


\subsubsection{Métodos relevantes de la clase \texttt{Component} }

\begin{itemize}
    \item \texttt{GetName()}: Devuelve el nombre del componente.
    \item \texttt{GetAttribute()}: Permite obtener un atributo específico de un componente mediante su nombre. 
    \item \texttt{GetFunction()}: Permite obtener una función específica de un componente utilizando su nombre
    \item \texttt{FromJson()}: Reconstruye un componente a partir de un fragmento en formato JSON.
    \item \texttt{ToJson()}: Lleva a cabo la serialización integral de la información del componente y sus atributos y funciones 
    asociadas en un archivo en formato JSON. 
\end{itemize}


\subsubsection{Métodos relevantes de la clase \texttt{Entidad} para la gestión de componentes }

\begin{itemize}
    \item \texttt{AddComponent()}: Añade un componente a la entidad.
    \item \texttt{GetComponents()}: Devuelve el mapa de componentes de la entidad.
    \item \texttt{SetComponents()}: Recibe y una lista de componentes para asignarsela a la entidad.
\end{itemize}

En resumen, los componentes y su relación con las entidades en el motor permiten una estructuración eficiente y una personalización 
precisa de la funcionalidad de cada elemento en el mundo virtual, enriqueciendo la experiencia del usuario y posibilitando un proceso 
de desarrollo más fluido y adaptativo.


\subsection{Scripts}

\textbf{\textit{TODO: Completar\ldots}}

%-------------------------------------------------------------------
\section{Motor}
%-------------------------------------------------------------------
\label{cap4:sec:motor}

El motor esta dividio en diez proyectos de Visual Studio, todos dentro de la misma solución.
Cada proyecto cumple una función específica de la que pueden depender otros proyectos. 

A continuación se entrará en detalle sobre la función y detalles de implementación de cada
proyecto y de las librerías asociadas al mismo, si las tiene.

\subsection{Proyecto de utilidades}

El objetivo de este proyecto es implementar código común que pueden necesitar el resto 
de proyectos evitando así la duplicación de código innecesaria.

Contiene clases tanto orientadas a guardar información como a implementar lógica y funcionalidad.

Entre estas clases destacan las siguientes:

\begin{itemize}

\item Vector2D: Representa un vector bidimensional, contiene información de dos componentes e implementa 
muchas de sus operaciones básicas. En este caso, esta clase se puede usar simplemente como un contenedor de 
información en el que se pueden asociar dos números reales pero también se puede usar para hacer cálculos
geométricos en dos dimensiones como rotaciones, cálculo de ángulos, etc.

\item Random: Contiene métodos estáticos útiles para calcular aleatoriedad entre números enteros, 
números reales, ángulos, y colores. En este caso esta clase solo tiene como objetivo proporcionar
funcionalidad.

\item Color: Representa un color de tres canales (Red, Green, Blue) además de métodos con algo de
funcionalida como Lerp, que calcula un color intermedio entre otros dos dados y un porcentaje 
que representa la influencia que tendrá cada color en el color resultante. También existen métodos
que aportan comodidad a la hora de crear colores como Red, Green, Blue, Orange, Black, que simplemente
construyen el color por dentro sin necesidad de conocer su valor en el modelo RGB.

\item EngineTine: Por un lado, contiene información sobre el tiempo entre fotogramas del motor, 
tiempo entre pasos físicos, tiempo transcurrido desde el inicio del programa y número de fotogramas
hasta el momento. Por otro lado, implementa funcionalidad para conocer la tasa de frames o convertir 
un valor de tiempo en una cadena de texto formateada. Mencionar también que esta clase es un Singleton.

\item Singleton: Una plantilla para crear instancias estáticas a través de herencia. Es decir, en caso
de querer convertir una clases en un Singleton, muy útiles para managers, simplemente hay que heredar
de esta clases para conseguirlo. Aporta mucha comodidad ya que evita tener que implmentar la instancia
estática de la clase y sus métodos para manejarla. Solo tiene un incoveniente y es borrar los Singletons
en el orden adecuado si dependen entre ellos.

\end{itemize}

\subsection{Proyecto de recursos}

El objetivo de este proyecto es proporcionar un contenedor de recursos en el que se van a guardar
todos los recursos del videojuego. En concreto, el tipo de recursos que se pueden guardar son fuentes
de texto, imágenes, efectos de sonido y música.

El manager de recursos contiene un mapa por cada tipo de recurso donde la clave es la ruta del archivo
y el valor un puntero a un objeto del tipo del recurso (Texture*, Font*, SoundEffect*, Music*).
El hecho de utilizar un mapa se debe a la complejidad constante de acceder a los recursos una vez creados.

Esto es importante porque uno de los objetivos del manager de recursos es reutilizar los recursos creados
para solo tener cargada una copia de cada recurso en memoria. Por ello, a la hora de añadir un nuevo recurso
al manager, primero comprueba si ya lo contiene y en ese caso, lo devuelve, en caso contrario, lo crea.

Ya que la clave en los mapas es la ruta del archivo, los recursos pueden duplicarse en caso de tener
el mismo archivo en diferentes directorios. El manager no contempla ese escenario ya que realmente
el archivo también esta duplicado y es responsabilidad del desarrollador ordenar sus archivos de assets.

Por último, en la destructora de la clase se borran todos los recursos de todos los mapas.


\subsection{Proyecto de sonido}

El objetivo de este proyecto es construir un envoltorio sobre la librería de audio SDLMixer para
poder implementar posteriormente los componentes MusicEmitter y SoundEmitter.

Para un mejor entendimiento de la implementación es necesario saber que SDLMixer diferencia entre
efectos de sonido o sonidos cortos en general (WAV, MP3) y música de fondo (WAV, MP3, OGG).

Para la música (MixMusic), la librería solo cuenta con un canal de reproducción por lo que es
algo limitado pero simple a la vez ya que no hay que lidiar con número de canales, al contrario
que con los efectos de sonido (MixChunk).

Este proyecto cuenta con tres clases:

\begin{itemize}

\item SoundEffect: Representa un efecto de sonido. Contiene la información de un MixChunk de
SDLMixer y un identificador usado posteriormente por el componente SoundEmitter.

\item MusicEffect: Representa un sonido de música de fondo. Contiene la información de un
MixMusic de SDLMixer y un identificador usado posteriormente por el componente MusicEmitter.

Estas dos clases representan también los recursos que se usan para música y sonidos en el 
manager de recursos.

\item SoundManager: Manager singleton encargado de implementar el envoltorio de las funciones principales 
de SDLMixer para reproducir, parar, y detener sonidos, entre otros. Tiene dos métodos destinados al 
usuario para el modificar el volumen general y cambiar el número de canales disponibles para la reproducción
de efectos de sonidos.

\end{itemize}

En cuanto a los sonidos, todos los métodos de SDLMixer necesitan un canal y un MixChunk*. 
Esto choca con la idea del componente SoundEmitter, que visto desde la perspectiva del usuario, 
simplemente se le establece un sonido y ya se puede reproducir, sin necesidad de conocer la existencia 
de canales. Esto se contará más en detalle en la implementación de SoundEmitter.

Las funciones disponibles para los canales de sonido son: reproducir, fade-in, fade-out, pausar, detener 
(la diferencia con pausar es que si se detiene no se puede renaudar), renaudar, consultar si un canal está
reproduciendo un sonido, establecer el sonido de un canal, consultar el volumen de un canal, establecer la posicion
en el espacio 2D de un canal y establecer el paneo de un canal.

En cuanto a la música, los métodos de SDLMixer solo necesitan un MixMusic ya que solo hay un canal
por lo que el problema de los canales desaparece. Las funciones disponibles son: reproducir, fade-in,
fade-out, pausar, detener, renaudar, modificar el volumen de la música y rebobinar.


\subsection{Proyecto de input}

Este proyecto tiene como objetivo implementar un manager, también Singleton, que contendrá la información del
estado de las teclas/botones de los dispositivos de entrada. En concreto, cuenta con soporte para teclado,
ratón y mando.

En el manager, las teclas/botones pueden pasar por diferentes estados los cuales se establecen al recibir determinados
eventos de SDL y se actualizan debidamente.

Estos estados se dividen en:

- Down: Una tecla esta siendo pulsada.
- Up: Una tecla no esta siendo pulsada.
- Pressed: Una tecla acaba de ser pulsada.
- Released: Una tecla acaba de ser soltada.

\begin{itemize} 

\item Teclado: Guarda la información sobre la mayoría de teclas importantes de un teclado. Letras, números y teclas especiales. 
Para ello, el manager cuenta con tres enumerados que contienen el nombre de cada una de las teclas para cada tipo. Con estos
enumerados se crean posteriormente arrays con la información del estado de cada tecla.

Los eventos de SDL relacionados con el teclado son KEYDOWN y KEYUP. 
El manager implementa métodos de usuario para conocer si se ha pulsado o soltado alguna tecla o si una tecla está pulsada,
acaba de ser pulsada, acaba de ser soltada o no está pulsada.

\item Ratón: Guarda la información de la posición del ratón, del estado del clic izquierdo, clic central (de la rueda), clic 
derecho y movimiento de la rueda. Para ello, el manager cuenta con un Vector2D para la posición, booleanos para el estado de 
pulsado/no pulsado de los botones y un número entero para representar si la rueda del ratón está haciendo scroll hacia abajo 
o hacia arriba. 

Los eventos de SDL relacionados con el ratón son MOUSEWHEEL, MOUSEMOTION,  MOUSEBUTTONDOWN y MOUSEBUTTONUP.
El manager implementa métodos de usuario para conocer si ha habido algún movimiento con el ratón o con la rueda, si se ha
pulsado o soltado algún botón, la posición del ratón y el scroll actual de la rueda.

\item Mando: Cuenta con soporte para múltiples mandos y cada uno de ellos guarda la siguiente información:  

- Referencia al GameController creado por SDL.
- Id del GameController creado por SDL.
- Nombre del GameController.
- Estado de cada uno de los botones del GameController.
- Información del movimiento de los triggers del GameController.
- Información del movimiento de los joysticks del GameController.

El manager tiene sporte además para conexiones y desconexiones durante la ejecución.
Debido a la posibilidad de tener varios mandos conectados el manager diferencia entre métodos con identificador
y métodos sin identificador. Los métodos con identificador reciben el identificador del mando del que se quiere
consultar el estado y los métodos sin identificador devuelven la información del estado del último mando que 
registró input. De esa manera, si se quiere desarrollar un singleplayer, el usuario no tendrá que preocuparse
por la posibilidad de múltiples mandos teniendo que indicar que identificador tiene su mando. 

Los eventos de SDL relacionados con el ratón son CONTROLLERDEVICEADDED, CONTROLLERDEVICEREMOVED, JOYBUTTONDOWN,
JOYBUTTONUP, JOYAXISMOTION. El manager implementa métodos de usuario para conocer el número de mandos conectados,
si algún mando ha pulsado o soltado algún botón, si algún mando ha movido los joysticks o los triggers y si ha
habido alguna conexión o desconexión.

Comentar también que, antes de esta implementación, el manager usaba SDLJoystick para el manejo de los mandos
pero debido a cierta incomodidad con los eventos se hizo el cambio a SDLGameController. La diferencia entre
ambos es que SDLJoystick es la API más antigua de SDL para manejar mandos y joysticks y proporciona una interfaz
de bajo nivel para interactuar con dispositivos de entrada mientras que SDLGameController proporciona una abstracción
de más alto nivel para interactuar con mandos, lo que facilita la detección de mandos y el acceso a sus entradas y 
es la opción recomendada para la mayoría de los desarrolladores.

\end{itemize}

Por último, el manager implementa métodos de lógica para el usuario como movimiento horizontal y vertical,
salto o acción. Estos métodos usan la información que se haya establecido en el editor de las teclas y botones
que se desean usar para moverse, saltar o realizar una acción.


\subsection{Proyecto de consola}

Este proyecto contiene una sola clase Output con métodos estáticos que implementan funcionalidad relacionada
con el mostrado de la salida estándar por la consola.

Tiene métodos para imprimir por consola con los colores por defecto, imprimir una advertencia, con color 
amarillo e imprimir un error, con color rojo, entre otros.

Además de ser útil para el desarrollo, sirve también para dar formato a los mensajes que aparecen por la 
consola del editor. Se utiliza una tubería o pipe para conectar la consola del motor y la del editor. Esto
se cuenta más en detalle en el apartado de editor.


\subsection{Proyecto de físicas}

Este proyecto tiene como objetivo implementar un envoltorio sobre la librería de físicas Box2D para proporcionar
una API sencilla para el usuario y para desarrollar los componentes de colisión y movimiento físico necesarios.

Antes de nada, al igual que con SDLMixer, algunos comentarios sobre la librería: 

\begin{itemize}

\item Mundo físico: La librería tiene una clase b2World que representa un mundo físico donde se pueden crear
cuerpos físicos. Esta clase tiene un método fundamental Step(), al que se debe llamar para realizar un paso físico,
lo que actualiza la simulación al avanzar el tiempo en un intervalo fijo, realiza cálculo de colisiones, resuelve 
restricciones y actualiza posiciones y velocidades. 

\item Unidades: Box2D trabaja con números de punto flotante y es necesario tener en cuenta alguna restricciones
para que Box2D funcione correctamente. Estas restricciones han sido ajustadas para funcionar bien con unidades de 
metros-kilogramos-segundos (MKS). En particular, Box2D ha sido ajustado para funcionar adecuadamente con formas en
movimiento que tienen dimensiones entre 0.1 y 10 metros.

\item Pixeles: Es tentador usar pixeles como unidades para los tamaños, posiciones, fuerzas o velocidades pero 
desafortunadamente, esto llevaría a una simulación ineficiente y posiblemente a un comportamiento extraño. 
En la propia documentación de Box2D comentan que un objeto de 200 píxeles de longitud sería visto por Box2D como el 
tamaño de un edificio de 45 pisos.

Para resolver el problema de los pixeles, el manager declara una variable 'screenToWorldFactor'  usada para convertir
de pixeles a unidades físicas y viceversa. Por lo tanto, a la hora de crear cuerpos físicos se convierte el tamaño
en pixeles deseado por el usuario a unidades físicas utilizando ese factor de escala.

\end{itemize}

Las clases que tiene este proyecto son las siguientes:

\begin{itemize}

\item PhysicsManager: Clase, Singleton, que contiene la funcionalidad necesariara para manejar el filtrado de 
colisiones e información sobre gravedad del mundo físico así como la matriz de colisiones y capas existentes.

En cuanto al filtrado de colisiones, Box2D proporciona los CategoryBits y los MaskBits para ello. Los CategoryBits
especifican la capa en la que se encuentra un objeto y los MaskBits las capas con las que colisiona. Para que se 
produzca una colisión, los cuerpos deben cumplir una condición, y es que, la capa del cuerpo A debe de estar marcada
para que colisione con la del cuerpo B y viceversa.

Tanto los CategoryBits como los MaskBits se representan en hexadecimal y el su valor por defecto es 0x0001 en caso
de los CategoryBits y 0xFFFF en caso de los MaskBits. 

La comprobación de colisión tiene este aspecto:

bool colision = (bodyA.maskBits AND bobyB.categoryBits) == 0 Y (bodyA.categoryBits AND bobyB.maskBits) == 0

Por lo tanto, por defecto, todos los cuerpo creados va a estar en la capa 0x0001 y van a colisionar con todas las capas.

El manager guarda un mapa para las capas donde la clave es el nombre de la capa y el valor un indice que la representa.
Cuando se crea un nuevo cuerpo físico, se calcula su CategoryBits a partir de ese indice.

Para calcular sus MaskBits entra en juego otro funcionalidad que es la matriz de colisiones. En ella se ajustan
la colisión entre las capas existentes y posteriormente se calculan los MaskBits de una capa dada.

Como métodos al usuario, el manager proporciona pdoer cambiar la gravedad del mundo físico, añadir o eliminar capas, 
establecer colisión entre capas y consultar si dos capas colisionan.

\item DebugDraw: Clase que contiene la funcionalidad para dibujar los cuerpos físicos de Box2D. En concreto, puede
dibujar polígonos, círculos, segmentos y puntos. El dibujado se realiza con SDL y antes de dibujar, se utiliza el 
'screenToWorldFactor' para devolver la escala a los cuerpos, es decir, de unidades físicas a pixeles.

\end{itemize}


\subsection{Proyecto de renderer}

Este proyecto tiene como objetivo iniciar la librería de SDL y SDLImage.

Las clases que tiene este proyecto son las siguientes:

\begin{itemize}

\item RendererManager: Clase, singleton, encargada de inicializar y cerrar la librería de SDL, SDLImage y SDLTTF.
Contiene información y funcionalidad relacionada con la ventana como su tamaño, borde, icono, cursor, nombre y 
modo pantalla completa. Además, tiene la información de la cámara como su posición y escala. Proporciona los métodos renderizar y para 
limpiar la pantalla.

\item Font: Representa una fuente de texto y tiene la funcionalidad de crear una a partir de una fichero con .ttf
como extensión. Tiene también la funcionalidad de crear un texto o un texto ajustado mediante la creación de una textura.

\item Texture: Representa una textura y tiene la funcionalidad de crear una a partir de un fichero con una extensión de 
imagen como .png o .jpg. Tiene métodos para obtener la textura de SDL (SDLTexuture*) y para consultar el ancho y el alto
de la misma.

\end{itemize}

Al igual que SoundEffect y MusicEffect, Font y Texture representan los recursos utilizado en el manager de recursos
para almacenar fuentes de texto e imágenes.


\subsection{Proyecto de Entity-Component-System}

Este es el proyecto más importante del motor. Implementa el sistema de entidades y componentes, componentes fundamentales
para el usuario y una serie de managers como el de escenas, prefabs, referencias y overlay.

Para empezar, la idea un sistema de componentes y entidades es la siguiente: 

Es un patrón de diseño utilizado en el desarrollo de videojuegos y otros sistemas interactivos para organizar y gestionar la lógica
y la funcionalidad de los objetos dentro del juego. En lugar de utilizar una jerarquía de clases tradicional o un sistema basado en 
objetos, el ECS descompone los elementos del juego en dos partes principales: entidades y componentes.

\begin{itemize}

\item Entidades: Las entidades son objetos vacíos que actúan como contenedores para componentes. Cada entidad representa un objeto o 
entidad en el juego, como un personaje, un enemigo, un objeto interactivo, etc. Las entidades no tienen lógica o comportamiento en sí mismas,
simplemente contienen uno o más componentes.

\item Componentes: Los componentes son bloques de datos y lógica que contienen información específica sobre el comportamiento o las propiedades de una
entidad en el juego. Cada componente se enfoca en una única funcionalidad o característica del objeto. Por ejemplo, puedes tener un componente 
de "Posición" para almacenar la posición de una entidad en el mundo, un componente de "Renderizado" para pintar la entidad en la escena, un 
componente de "Física" para gestionar su comportamiento físico, etc.

\end{itemize}

Para llevar a cabo la implementación de este sistema es imprescindible el uso de programación orientada a objetos (POO) junto con herencia
y polimorfismo.

En cuanto a las clases implementadas: 

- Component: Clase que representa a un componente. Contiene una referencia a la entidad a la que está asociado e información sobre si esta activo o
eliminado. Desde un componente se puede acceder a la entidad y escena que lo contiene y establecer su estado, es decir, activarlo o desactivarlo y 
eliminarlo. Además, contiene una serie de métodos virtuales preparados para ser implementados por los componentes que hereden de esta clase.

Estos métodos son los siguientes:

\begin{itemize}

\item Init: Método reservado para el motor donde se realiza toda la inicialización que necesita el componente para funcionar correctamente.

\item Start: Método llamado inmediatamente después del Init donde el usuario puede realizar su propia inicialización. 

\item Update: Método llamado en cada vuelta del bucle principal.

\item LateUpdate: Método llamado en cada vuelta del bucle principal inmediatamente después del Update.

\item Render: Método llamado después del Update y LateUpdate. Destinado a implementar el renderizado del componente.

\item FixedUpdate: Método llamado en un intervalo de tiempo fijo denominado paso físico. Destinado a implementar la física del componente.

\item OnActive: Método llamado cuando se activa el componente.

\item OnDeactive: Método llamado cuando se desactiva el componente.

\item OnSceneUp: Método llamado cuando el componente se encuentra en la escena que se acaba de empezar a actualizar.

\item OnSceneDown: Método llamado cuando el componente se encuentra en la escena que se ha dejado de actualizar.

\item OnDestory: Método llamado cuando el componente es eliminado.

\end{itemize}

Métodos para el manejo de colisiones: 

\begin{itemize}

\item OnCollisionEnter: Método llamado cuando la entidad que contiene este componente ha colisionado con otra entidad.

\item OnCollisionStay: Método llamado cuando la entidad que contiene este componente está colisionando con otra entidad.

\item OnCollisionExit: Método llamado cuando la entidad que contiene este componente ha dejado de colisionar con otra entidad.

\item OnTriggerEnter: Método llamado cuando la entidad que contiene este componente ha colisionado con otra entidad y, o bien 
el componente físico de esta entidad o bien el de la otra están marcados como trigger.

\item OnTriggerStay: Método llamado cuando la entidad que contiene este componente está colisionando con otra entidad y, o bien 
el componente físico de esta entidad o bien el de la otra están marcados como trigger.

\item OnTriggerExit: Método llamado cuando la entidad que contiene este componente ha dejado de colisionar con otra entidad y, 
o bien el componente físico de esta entidad o bien el de la otra están marcados como trigger.

Métodos para el Overlay (UI):

\item OnClickBegin: Método llamado cuando se hace click sobre un elemento del componente Overlay de la entidad.

\item OnClickHold: Método llamado cuando se mantiene clickado un elemento del componente Overlay de la entidad.

\item OnDoubleClick: Método llamado cuando se hace doble click sobre un elemento del componente Overlay de la entidad.

\item OnRightClick: Método llamado cuando se hace click derecho sobre un elemento del componente Overlay de la entidad.

\item OnMouseEnter: Método llamado cuando el ratón entra sobre un elemento del componente Overlay de la entidad.

\item OnMouseHover: Método llamado cuando el ratón se encuentra sobre un elemento del componente Overlay de la entidad.

\item OnMouseExit: Método llamado cuando el ratón sale de un elemento del componente Overlay de la entidad.

\end{itemize}

- Entity: Clase que representa una entidad. Contiene una referencia a la escena en la que se encuentra, una lista de 
componentes y otra de scripts asociados a esta entidad. Tiene información sobre el nombre de la entidad, su estado, activa y
eliminada, un identificador y su orden de renderizado.

En cuanto a funcionalidad, contiene los mismos métodos que los componentes pero con implementación. Esta implementación
simplemente consiste en llamar a los métodos de todos los componentes asociados a la entidad. Por ejemplo, el método 
Render de la entidad recorre la lista de componentes asociados y llama al método Render de cada uno. Aquí es donde
entra la importancia de la herencia y el polimorfismo. Para crear un componente con funcionalidad, se debe heredar
de la clase Componente e implementar los métodos virtuales disponibles. De esta manera, serán llamados por la entidad
que contenga el componente creado.

Además de los métodos de los componentes, las entidades tiene métodos para añadir componentes, consultar si contienen
un componente, eliminar componentes y obtenerlos. Estos métodos hacen uso de templates de C++ con un tipo genérico 
T y una restricción para asegurar que el T debe ser de tipo componente. Además, los parámetros de éstos métodos reciben
un paquete de parámetros variados de categoria RValue, por lo que dentro se utiliza la función std::forward para preservar
esa categoría y evitar así copias innecesarias y garantizar un comportamiento predecible.

Por último mencionar que las entidades también tienen métodos para añadir scripts. La diferencia entre scripts y componentes
es que, ambos definen lógica para el videojuego pero los componentes son comportamiento, en la mayoría de casos, fundamental 
y genérico, que proporciona el motor al usuario y los scripts son piezas de lógica que construye el usuario a partir del
sistema de scripting visual y que, en general, es comportamiento específico al videojuego que esté desarrollando el usuario.

- Scene: La última pieza que compone este ECS son las escenas. Una escena es un conjunto de entidades. Es un concepto 
importante en los videojuegos ya que normalmente se quiere dividir el juego en estados como menús, gameplay, inventario,
pantallas de carga, mapa, etc. Contiene información sobre su nombre, la posición y escala de la cámara, y bastantes métodos
comunes a las entidades y componentes. No todos porque hay algunos que no tienen sentido en las escenas, como los de físicas
o los de UI. Al igual que las entidades, estos métodos cuentan con funcionalidad y simplemente se dedican a llamar al método
correspondiente de cada una de las entidades que contiene. Por ejemplo, cuando se actualiza una escena, el método Update
de la escena lo único que hace es llamar al Update de sus entidades comprobando si el estado de la entidad le permite actualizarse,
es decir, que esté activa y no esté eliminada.

Además, las escenas cuentan con métodos para crear entidades con identificador y sin identificador, buscar entidades por nombre, 
y eliminar entidades.


\subsubsection{Managers}

- SceneManager: Encargado de manjear las escenas. Para ello, cuenta con una pila en la que va almacenando las escenas que se crean.
La escena que se va actualizar en el juego es la que se encuentra en el top de la pila. Hay 5 operaciones que se pueden realizar:

1.- Operación PUSH: Cuando se cambia una escena y se especifica está operación, carga la escena y la añade al top de la pila, por 
lo que la escena añadida pasa a ser la que se actualiza en el juego. Antes de añadirla al top, llama al método OnSceneDown de la 
escena que está actualmente en el top para avisar de que esa escena va a dejar de actualizarse. Posteriormente, una vez añadida al top,
se llama al Start para la inicialización de la escena.

2.- Operación 





