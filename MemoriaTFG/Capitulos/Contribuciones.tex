%---------------------------------------------------------------------
%
%                          Contribuciones
%
%---------------------------------------------------------------------

\chapter{Contribuciones}

Como se comentó en el plan de trabajo, este TFG esta divido en tres partes fundamentales. Debido a que la carga
de trabajo de cada parte es similar, hemos asignado una parte a cada integrante del grupo. A pesar de esta división,
sobretodo durante la recta final del trabajo, se han dado contribuciones de todos los integrantes en cada una de las
tres partes, aunque eso sí, en menor medida.

%-------------------------------------------------------------------
\section{Pablo Fernández Álvarez}
%-------------------------------------------------------------------

Yo me he encargado de la parte del motor. Al principio me dediqué a investigar posibles librerías tanto de físicas
como de audio, para integrar al motor. En cuanto a librería de gráficos tuvimos claro desde el principio que íbamos
a usar SDL, debido a que la hemos usado bastante durante el grado y estamos acostumbrados, además de que no tiene
ninguna limitación para el desarrollo de videojuegos 2D. 

\medskip

Una vez escogidas la librerías, Box2D como motor de física y SDLMixer como motor de audio, comencé a montar el proyecto
usando Visual Studio 2022. Organicé la solución en varios proyectos, física, audio, input, render, y fui implementando
cada uno de ellos. Empecé con el proyecto de Input, el cuál me llevó algo de tiempo ya que implementé soporte para teclado,
mando y múltiples mandos. Una vez terminado, fue el turno del proyecto de sonido/audio. Con la ayuda de la documentación
de SDLMixer, implementé soporte para la reproducción de efectos de sonido/sonidos cortos y música. Posteriormente comencé
con el proyecto de físicas. En este caso tuve que dedicar bastante más tiempo a aprender sobre la librería, leer artículos
y documentación, ya que es más compleja. Investigué también la opción de poder visualizar los colisionadores de los cuerpos
físicos ya que supondría una gran ayuda tanto para el desarrollo del motor como para el usuario. En la documentación de Box2D
encontré algunos ejemplos pero usaban el OpenGL para el dibujado y el motor usa SDL por lo que tuve que implementar esas
funciones de dibujado con SDL.

\medskip

Luego llegó el momento de implementar el proyecto del ECS (Entity-Component-System), fundamental para realizar pruebas y 
visualizar las primeras escenas. Para ello además, implementé el bucle principal del motor con un intervalo de tiempo
fijo para el mundo físico. En este momento, con los proyectos principales implmentados, comencé a implementar los primeros
componentes básicos, como son el Transform, Image, PhyiscBody y SoundEmitter.

\medskip

Durante un tiempo simplemente me dediqué a ampliar y probar los componentes y la funcionalidad implementada en los proyectos.
Por ejemplo, añadí una matriz de colisiones al proyecto de físicas para manejar el filtrado de colisiones, implementé distintos
tipos de PhyiscBody (colisionadores con formas especiales), sincronicé los cuerpos físicos con las transformaciones de la entidad,
detección de colisiones, conversión de píxeles a unidades físicas, nuevo componente ParticleSystem para sistemas de partículas, 
implementé un gestor de recursos para evitar cargar recursos duplicados, mejoré los componentes de sonido para añadir paneo 
horizontal y sonido 2D, entre otros. 

Con la parte del editor más avanzada, implementé la lógica para leer los datos que genera el editor, como prefabs. Además, 
implementé la ventana de gestión de proyectos del editor, añadí control de errores en todo el motor, 
para conseguir una ejecución continua y esperable, imprimiendo los errores por la salida estándar. Añadí también control de 
errores en el editor, a través de un fichero de log, con la información de los errores durante la ejecución. Creé una estructura
de directorios para el editor y motor haciendo más cómodo el ciclo de desarrollo. Implementé una ventana de preferencias donde
ajustar parámetros del motor, como gravedad del mundo físico, frecuencia del motor de audio, tamaño de la ventana de juego, entre
muchos otros. Implementé el flujo de escenas, es decir, guardar la última escena abierta, mostrar el viewport de una forma especial
en caso de que no haya ninguna escena abierta y mostrar en el viewport el nombre de la escena actual junto con su contenido
correspondiente. 

\medskip

Por último, cambié el uso que se hacía de SDL para la implementación de mando en el Input, de SDLJoystick a SDLGameController ya
que está más preparada para mando y SDLJoystick es una interfaz de más bajo nivel preparada para cualquier tipo de dispositivo.
Añadí más parámetros a la ventana de preferencias, sobretodo para Input, bindeo de teclas rápidas. He mejorado también la ventana
de gestión de proyectos para poder eliminar proyectos y ordenar los proyectos por orden de última apertura.



%-------------------------------------------------------------------
\section{Yojhan Steven García Peña}
%-------------------------------------------------------------------

Mi principales tareas fueron el desarrollo del lenguaje de scripting, incluyendo su implementación tanto en el editor y en el motor, y también
la unión entre el editor y el motor.

\medskip

Inicialmente tuve que crear un proyecto vacío de Visual Studio para empezar a prototipar el lenguaje. No quería utilizar ninguna biblioteca externa
que implementase la lógica para un editor de nodos, pues prefería poder desarrollarlo desde cero. Tuve que buscar información de otros motores como Unity o Unreal y cómo funciona su scripting para implementarlo en nuestro motor, aunque tampoco queríamos copiar su forma de implementar el scripting o el diseño de su estructura de nodos y queríamos desarrollar un lenguaje propio
que se adaptase a las necesidades concretas de nuestro motor. En esta fase inicial se tuvieron que tomar las decisiones clave sobre cómo implementar el scripting, como por ejemplo hacer que el lenguaje de scripting fuese compilado a código en c++, o si debería ser interpretado.  \\

Fue un proceso iterativo donde poco a poco se iba añadiendo funcionalidad y haciendo una variedad de prototipos, usando Unity como base para la parte gráfica. En estos prototipos fue cuando probamos a hacer que un script fuera compilado, de forma que se mejorase el rendimiento del motor. Para ello creé lógica para su traducción a código en c++, con éxito en scripts pequeños que fueron probados. 
El siguiente paso sería compilarlo, y después de investigar como llevar a cabo el proceso de compilación para generar una DLL la cual
sería enlazada con el motor, no vimos ninguna solución que nos terminase de convencer, pues la mayoría requería de instalación de programas de compilación adicionales o no tenían soporte para la generación de DLLs, por lo que al final tras discutirlo los miembros del equipo decidimos que no se compilase el script sino que fuese interpretado por el motor.


Cuando dimos con una implementación suficientemente robusta fue cuando decidímos juntar los dos primeros proyectos del TFG, siendo el motor y el scripting. No bastaba solo con incluir los ficheros que tenía (adaptando algunos de c\# a c++ y añadiendo la biblioteca de JSON de nlohmann), sino que para poder llevar a cabo la integración tuve que crear una serie de clases del motor 
para que funcionasen como puente para el scripting. Esto incluye clases como Script y ScriptManager imprescindibles para poder llevar a cabo la unión. Con el scripting enlazado con el bucle de juego del motor fue momento de empezar a hacer pruebas y ver que todo funcionaba como se esperaba. En este punto fue necesaria la creación de la clase ScriptFunctionality para poder dotar al lenguaje de una funcionalidad básica operaciones aritméticas o salida por
consola para poder llevar a cabo las pruebas. \\

El scripting se encontró con un bloqueo pues no se podía acceder a la funcionalidad del motor, por lo que pospuse el desarrollo del scripting y empezé a centrarme en cómo sería la unión entre el editor y el motor. Después de investigar posibles soluciones y ver la carencias del lenguaje c++, decidimos solventar esas carencias a mano, por lo que surgió el proyecto de ECSReader,
 con el cual se puede leer el contenido del motor gracias a unas marcas que se pueden ir añadiéndo en el código. Estas marcas permiten al desarrollador decidir que partes se quieren hacer públicas para el editor. Con esta clase terminada, toda la información relevantes del motor
pasaba a estar serializada en un fichero en formato JSON, siendo la idea que el editor pueda leer los valores desde este fichero. Además, se usó el ECSReader ya no solo para generar ficheros JSON, sino para automatizar distintas partes del motor, ahorrando mucho tiempo de haber hecho eso a mano, como crear una factoría de componentes automática, permitir hacer reflexión sobre los atributos de un componente, y una parte fundamental
para continuar el desarrollo del scripting, que es poder tener un mapa con todas las funciones del motor para así poder utilizar su funcionalidad desde un script. Con esto hecho, continué haciendo pruebas con los scripts, ahora manejando funcionalidad del motor y corrigiendo todos los errores que iba encontrando.\\

La mejor forma de comprobar que el scripting funcionaba era utilizándolo de forma exhaustiva, por lo que comencé el desarrollo de varios juegos pequeños para ver si encontraba alguna limitación. Estos juegos eran un pequeño flappy bird y otro un reloj que daba la hora en tiempo real (realmente no se podría decirse que es un juego sino más bien una prueba). El problema
del desarrollo de scripts es que estaba enlazado con el motor, pero aún no con el editor, lo cual significaba que cada script lo tenía que hacer a mano, modificando el propio fichero desde un editor de texto, lo cual era bastante tedioso de hacer y se complicaba mucho cuando el script crecía de tamaño. Por ello, mi idea era implementar ya la ventana de edición de scripts
en el editor, pero debido a que el editor aún no estaba lo suficientemente avanzado decidí ayudar a Pablo en el desarrollo del motor. 
\medskip

Del motor terminé unas cosas que Pablo había dejado a medias y luego me puse a añadir funcionalidad adicional. Lo primero que añadí, debido a mi previa experiencia usando la biblioteca de JSON de nlohmann, fue la serialización de escenas y entidades. Con eso hecho me puse a implementar un sistema de Overlays, siendo los overlays los distintos elementos con los que cuenta
el motor para representar la interfaz de usuario, junto con sus componentes correspondientes (OverlayImage, OverlayText y OverlayButton). Además, también hice la estructura para la deserialización de valores que carga el motor, con información como el nombre del juego o el tamaño de la ventana, dejando margen para poder ser expandido con más valores en un futuro. Implementé 
funcionalidad para otorgar al motor de una jerarquía de entidades. También implementé lógica para dotar al motor de una splashScreen con el logo del motor.

Con esto, ya estaba hecha la reflexión con la que queríamos dotar al motor, y siendo la persona que más avanzada iba con su parte decidí ayudar a mis compañeros con algunas tareas. Empezando por el motor y gracias a mi experiencia con serialización de JSON, hice serialización de escenas y entidades, seguido de la implementación del sistema de Overlays y sus componenetes asociados
 (Image, Button y Text), la Splash Screen y la serialización de información del proyecto, como tamaño de la ventana o el icono usado. Implementé la lógica para mover la cámara por la escena, al igual que para poder cambiar su escala. Hice el renderManager dentro del ECS para poder controlar el orden de renderizado de las entidades. Por último, hice también un ConsoleManager 
 para poder mostrar elementos por consola con un formato unificado, mostrando que componente o script lo ha escrito, al igual que el momento en el tiempo en el que se escribió el mensaje. Todo esto con su respectivo manejo de errores. 


\medskip

Cuando el editor ya se encontraba en un estado más avanzado fue cuando empecé la implementación del editor visual de nodos en el editor. En el momento en el que todo se encontraba más o menos listo, pudiendo crear scripts y poder serializarlos y aprovechando que Iván se encontraba de viaje, procedí a hacer una refactorización general del sistema de ventanas, para permitir al usuario poder moverlas y agruparlas como mejor
le pareciese utilizando la rama experimental de docking de ImGui. Implementé la lectura de los datos que genera el motor, con la clase ComponentReader y ComponentManager. Procedí a cambiar la ventana de la escena y la forma en la que se renderizaban las entidades además de añadiendo la opción de renderizar elementos de la interfaz. Con todo esto listo, me dediqué a añadir 
funcionalidad adicional en el editor, pudiendo ejecutar el juego en una ventana nueva, con la funcionalidad adicional de poder detener su ejecución desde el editor en cualquier momento. También añadí funcionalidad para poder crear una build, reuniendo los assets necesarios junto con el ejecutable del motor en una única carpeta, modificando el nombre e icono del fichero ejecutable. 
Otras ventanas que añadí fue el esqueleto básico de la ventana de preferencias, el manejador de docking para cambiar la distribución de la ventana y la ventana de modificación de paletas de colores.

\medskip

Por últimos, estuvimos desarrollando juegos con el editor y el motor, corrigiendo los errores que nos íbamos encontrando. Además, fui quien preparó y llevó a cabo las pruebas con usuarios.




%-------------------------------------------------------------------
\section{Iván Sánchez Míguez}
%-------------------------------------------------------------------

Mi principal responsabilidad en el proyecto se enfocó en el desarrollo del editor. En una fase inicial, mi tarea consistió en llevar a cabo una investigación exhaustiva de proyectos similares para comprender 
las bibliotecas gráficas utilizadas y evaluar si alguna de ellas podría simplificar nuestro trabajo. Después de un análisis minucioso, llegué a la conclusión de que IMGUI era la elección ideal debido a su 
amplio conjunto de funcionalidades para la interfaz de usuario (UI).

\medskip

Una vez seleccionada esta biblioteca, procedí a crear el proyecto en Visual Studio 2022. Inicié con la creación de un programa simple inicial para comprender cómo se inicializa y funciona IMGUI, el cual incluía 
un proyecto con numerosos ejemplos. Mi enfoque inicial se centró en el diseño de las ventanas principales, como la barra de menú, la jerarquía, la escena, los componentes y el explorador de archivos.
Esto se hizo de manera rápida y provisional con el único propósito de familiarizarme rápidamente con IMGUI. Durante este proceso, descubrí la rama Docking de ImGUI, que permitía el anclaje de ventanas entre 
sí, lo que resultó ser una característica valiosa para el proyecto.

\medskip

Posteriormente, reestructuré dicho código para lograr una organización más intuitiva de las ventanas y facilitar la adición de nuevas ventanas. Para ello, cree la clase Window, que es la clase padre de cada 
ventana y se encarga de incluir la funcionalidad básica de una ventana de ImGUI. Avanzando en el proyecto, me concentré en la creación de la escena, un proceso que inicialmente resultó un tanto complicado 
debido a la complejidad en la programación, especialmente en lo que respecta al manejo de texturas y su renderización con ImGUI. Sin embargo, con el tiempo, logré comprender estos aspectos y refactorizar 
el código para obtener una forma más sencilla de renderizar la escena y sus entidades.

\medskip

Con la escena en funcionamiento, me dediqué a trabajar en la creación de entidades y su representación en la textura. Para ello, creé la clase Entidad, encargada de gestionar su textura y almacenar información 
sobre su \texttt{Transform}, además de asignar un ID único a cada entidad para diferenciarlas entre sí. Luego, me enfoqué en la gestión de estas entidades a través de la ventana de jerarquía, incorporando un listado 
con textos seleccionables mediante ImGUI, lo que permitió la selección de entidades. Esto también tuvo un impacto en otras ventanas, como la de componentes, que mostraba información sobre la entidad seleccionada. 
Inicialmente, la ventana de componentes mostraba solo la información del \texttt{Transform} con entradas de ImGUI para modificar sus valores. Finalmente, desarrollé la ventana del explorador de archivos, que aunque 
al principio no la consideré esencial, resultó importante para la visualización de los assets del proyecto y la navegación entre directorios.

\medskip

Una vez que logramos tener una versión básica del editor, trabajé en su integración con el motor del proyecto. Esto implicó la serialización de escenas, entidades y sus transformaciones en formato JSON.
Posteriormente, tuve que adaptar el proceso de serialización para que fuera compatible con el motor, ya que este tenía formas distintas de leer los componentes disponibles, sus atributos y el tipo de sus atributos. 
Una vez incorporados los componentes del motor en el editor, me centré en el renderizado y la edición de estos, de modo que cada tipo de atributo tuviera su propia representación en la ventana de componentes, 
lo que se logró de manera eficiente gracias a ImGUI. También permití la adición de dichos componentes a las entidades.

\medskip

Posteriormente, me dediqué a la implementación de funciones más avanzadas, como el uso de prefabs y la gestión de la jerarquía entre entidades. Esto fue un desafío significativo, ya que implicaba rehacer el 
sistema de asignación de IDs para que los prefabs tuvieran IDs negativos y estuvieran referenciados en todas sus instancias. Además, fue necesario tener en cuenta este sistema de IDs en múltiples partes del 
código para evitar conflictos con el uso normal de las entidades. La gestión de la jerarquía también presentó complejidades, ya que cada entidad contenía referencias a su padre y sus hijos, lo que debía 
considerarse en numerosas partes del código. La interacción entre prefabs y la jerarquía también fue un aspecto desafiante, ya que un prefab podía tener hijos. Después, implementé un sistema para que las entidades 
padre afectaran el \texttt{Transform} de sus hijos, lo que facilitó la interacción entre ellos en la escena, como el movimiento conjunto de las entidades al mover el padre. Además, para gestionar los prefabs, 
creé una ventana llamada PrefabManager desde la cual se podían ver y editar los prefabs.

\medskip

Finalmente, junto con el equipo, nos esforzamos en mejorar el editor y corregir sus errores. Para poner a prueba nuestro trabajo, desarrollé una versión básica del juego Space Invaders en nuestro propio
editor, identificando y resolviendo numerosos errores en el proceso.