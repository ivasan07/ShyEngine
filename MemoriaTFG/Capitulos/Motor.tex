%---------------------------------------------------------------------
%
%                          Motor
%
%---------------------------------------------------------------------

\chapter{Motor}

\section{Cómo funciona y cómo está dividio}

El motor esta dividido en diez proyectos de tecnología y cada uno cumple una función específica.

\medskip

A continuación se entrará en detalle sobre la función y detalles de implementación de cada proyecto y de las librerías asociadas al mismo, si las tiene.


% ----------------------------------------------- UTILIDADES -------------------------------------------------

\subsection{Utilidades}

El objetivo de este proyecto es implementar código común que pueden necesitar el resto  de proyectos evitando así la duplicación de código innecesaria.
Contiene clases tanto orientadas a guardar información como a implementar lógica y funcionalidad.

\medskip

Unos ejemplos de estas clases serían:

\begin{itemize}

    \item \texttt{Vector2D}: Representa un vector bidimensional, contiene información de dos componentes e implementa muchas de sus operaciones básicas. 
    
    \item \texttt{Random}: Contiene métodos estáticos útiles para calcular aleatoriedad entre números enteros, números reales, ángulos, y colores. 
    
    \item \texttt{Color}: Representa un color de tres canales (Red, Green, Blue) además de métodos con algo de funcionalidad como \texttt{Lerp}, que calcula
    un color intermedio entre otros dos dados.
    
    \item \texttt{Singleton}: Una plantilla para crear instancias estáticas a través de herencia. Es decir, en caso de querer convertir una clases en un 
    \texttt{Singleton}, muy útiles para managers, simplemente hay que heredar de esta clase  para conseguirlo. 
    
\end{itemize}




% ----------------------------------------------- RECURSOS -------------------------------------------------

\subsection{Recursos}

El objetivo de este proyecto es proporcionar un contenedor de recursos en el que se van a guardar todos los recursos del videojuego. En concreto, el tipo de
recursos que se pueden guardar son fuentes de texto, imágenes, efectos de sonido y música.

\medskip

Uno de los objetivos del manager de recursos es reutilizar los recursos creados para solo tener cargada una copia de cada recurso en
memoria. Por ello, a la hora de añadir un nuevo recurso al manager, primero comprueba si ya lo contiene y en ese caso, lo devuelve, en caso contrario, lo crea.

% ----------------------------------------------- SONIDO -------------------------------------------------

\subsection{Sonido}

El objetivo de este proyecto es construir un envoltorio sobre la librería de audio \texttt{SDL\_Mixer} para poder implementar posteriormente los componentes de emisión de música y de sonidos.

\medskip

Para un mejor entendimiento de la implementación es necesario saber que \texttt{SDL\_Mixer} diferencia entre efectos de sonido o sonidos cortos en general (WAV, MP3)
y música de fondo (WAV, MP3, OGG).

\medskip

Para la música, la librería solo cuenta con un canal de reproducción por lo que es algo limitado pero simple a la vez ya que no hay que lidiar con el número de canales, 
al contrario que con los efectos de sonido.

\medskip

Este proyecto cuenta con tres clases para representar y manejar sonidos:

\begin{itemize}

\item \texttt{SoundEffect}: Representa un efecto de sonido y contiene un identificador para diferenciado de otro sonidos.

\item \texttt{MusicEffect}: Representa un sonido de música de fondo. Al igual que \texttt{SoundEffect}, contiene un identificador para diferenciarse. Estas dos clases representan también los recursos que se usan para música y sonidos en el 
manager de recursos.

\item \texttt{SoundManager}: Manager \texttt{Singleton} encargado de implementar las funciones principales para reproducir, parar,
y detener sonidos, entre otros. También métodos destinados al usuario para modificar el volumen general y cambiar el número de canales disponibles para la reproducción
de efectos de sonidos.

\end{itemize}


% ----------------------------------------------- INPUT -------------------------------------------------

\subsection{Input}

Este proyecto tiene como objetivo implementar un manager, también \texttt{Singleton}, que contendrá la información del estado de las teclas/botones de los dispositivos de
entrada. En concreto, cuenta con soporte para teclado, ratón y mando.

\medskip

En el manager, las teclas/botones pueden pasar por diferentes estados los cuales se establecen al recibir determinados
eventos.

\medskip

Estos estados se dividen en:

\begin{itemize} 
    \item \textit{Down}: Una tecla esta siendo pulsada. 
    \item \textit{Up}: Una tecla no esta siendo pulsada. 
    \item \textit{Pressed}: Una tecla acaba de ser pulsada. 
    \item \textit{Released}: Una tecla acaba de ser soltada. 
\end{itemize} 

Algo a tener en cuenta es que debido a la posibilidad de tener varios mandos conectados, el manager diferencia entre métodos
con identificador y métodos sin identificador. Los métodos con identificador reciben el identificador del mando del que se quiere consultar el estado y los métodos sin identificador
devuelven la información del estado del último mando que registró input. De esa manera, si se quiere desarrollar un singleplayer, el usuario no tendrá que preocuparse por la posibilidad
de múltiples mandos teniendo que indicar que identificador tiene su mando. 

\medskip

Además, el manager tiene soporte además para conexiones y desconexiones durante la ejecución, e implementa métodos con lógica usada frecuentemente como lo es el movimiento horizontal para facilitar su implementación al usuario. 

% ----------------------------------------------- CONSOLA -------------------------------------------------

\subsection{Consola}

Este proyecto contiene una sola clase Output con métodos estáticos que implementan funcionalidad relacionada con el mostrado de la salida estándar por la consola. Tiene métodos para imprimir texto estandar, advertencias o errores. Estos textos se diferencian por su color y sirven principalmente como ayuda para el desarrollo de un videojuego.

% ----------------------------------------------- FISICAS -------------------------------------------------

\subsection{Físicas}

Este proyecto tiene como objetivo implementar un envoltorio sobre la librería de físicas Box2D para proporcionar una API sencilla para el usuario y para desarrollar los componentes de colisión
y movimiento físico necesarios.

\medskip

La física esta representada en un ``mundo físico'' donde se pueden crear cuerpos afectados por la física. La simulación de este mundo tiene la peculiaridad de que se actualiza por intervalos de tiempo fijos, lo que se conoce como ``paso físico''. En estos ``pasos físicos'' se realizan cálculos de colisiones, se resuelven restricciones y se actualizan las
posiciones y velocidades de los cuerpos. 

\medskip

Las clases que tiene este proyecto son las siguientes:

\begin{itemize}
    \item \textit{PhysicsManager}: Clase, \texttt{Singleton}, que contiene la funcionalidad necesariara para manejar el filtrado de colisiones e información sobre gravedad del mundo físico. Cada objeto físico tiene información sobre en que capa se encuentra y con que capas colisiona. Para que se produzca una colisión,
    los cuerpos deben cumplir una condición, y es que, la capa del cuerpo A debe de estar marcada para que colisione con la del cuerpo B y viceversa.

    \item \textit{DebugDraw}: Clase que contiene la funcionalidad para dibujar los cuerpos físicos de Box2D. En concreto, puede dibujar polígonos, círculos, segmentos y puntos.
\end{itemize}


% ----------------------------------------------- RENDERER -------------------------------------------------

\subsection{Renderer}

Este proyecto es el que se encarga de mostrar las texturas y fuentes en pantalla, así como limpiar la pantalla o guardar información sobre ella. Hace uso de las librería de SDL, SDL\_Image y SDL\_TTF.

\medskip

Las clases que se encargan de estas funciones son:

\begin{itemize}
    \item \textit{RendererManager}: Clase, \texttt{Singleton}, encargada de inicializar y cerrar la librería de SDL, SDL\_Image y SDL\_TTF. Contiene información y funcionalidad relacionada con la ventana como su
    tamaño, borde, icono, cursor, nombre y modo pantalla completa. Además, proporciona los métodos para renderizar y para limpiar la pantalla.

    \item \textit{Font}: Representa una fuente de texto y tiene la funcionalidad de crear una a partir de una fichero con \textit{'.ttf'} como extensión. Tiene también la funcionalidad de crear un texto o un
    texto ajustado mediante la creación de una textura.

    \item \textit{Texture}: Representa una textura y tiene la funcionalidad de crear una a partir de un fichero con una extensión de imagen como \textit{'.png'} o \textit{'.jpg'}.
\end{itemize}




% ----------------------------------------------- ENTITY COMPONENT ARQUITECTURE -------------------------------------------------

\subsection{Arquitectura de gameplay}

Como arquitectura de gameplay se ha implementado de tipo entidades y componentes (EC).

Este es el proyecto más importante del motor. Implementa la arquitectura, componentes fundamentales para el usuario y una serie de managers como el de escenas, prefabs, referencias y overlay.

\medskip

Para llevar a cabo la implementación de la arquitectura es imprescindible el uso de programación orientada a objetos (POO) junto con herencia y polimorfismo. 

\medskip

La partes fundamentales de esta arquitectura son las siguientes: 

\begin{itemize}
    \item \textit{Component}: Clase que representa a un componente. Contiene una referencia a la entidad a la que está asociado e información sobre si esta activo o eliminado. Desde un componente se puede 
    acceder a la entidad y escena que lo contiene y establecer su estado, es decir, activarlo o desactivarlo y eliminarlo. Además, contiene una serie de métodos virtuales preparados para ser implementados
    por los componentes que hereden de esta clase.

    \item \textit{Entity}: clase que representa una entidad. Contiene una referencia a la escena en la que se encuentra, una lista de componentes y otra de scripts asociados a esta entidad. Tiene información 
    sobre el nombre de la entidad, su estado, activa y eliminada, un identificador y su orden de renderizado.

    \item \textit{Scene}: La última pieza que compone esta arquitectura son las escenas. Una escena es un conjunto de entidades. Es un concepto importante en los videojuegos ya que normalmente se quiere dividir
    el juego en estados como menús, gameplay, inventario, pantallas de carga, mapa, etc. Contiene información sobre su nombre y bastantes métodos comunes a las entidades y componentes.
\end{itemize}

Como hemos dicho anteriormente, las entidades funcionan como contenedores y los que realmente implementan la funcionalidad son los componentes. Por ello, las entidades únicamente se encarga de mantener 
actualizados a todos los componentes que tengan asociados. Además de los métodos para actualizar a los componentes, las entidades tiene métodos para añadir componentes, consultar si contienen un componente y 
eliminarlos.

\subsubsection{Managers y componentes}

Por otro lado, en este proyecto se implementan también los managers necesarios para el funcionamiento del motor y los componentes fundamentales que el motor va a proporcionar al usuario.

\medskip

En cuanto a los componentes:

\begin{itemize}

    \item \textit{Transform}: Contiene la información sobre la posición, rotación y escala de la entidad. Además implementa algunos métodos para rotar, escalar y mover la entidad.

    \item \textit{Overlay}: Componente encargado de representar los elementos de la interfaz de usuario como textos, imágenes y botones.

    \item \textit{Image}: Componente encargado de cargar una imagen y renderizarla en pantalla en la posición indicada por el transform de la entidad. Para cargar la imagen hace uso del manager de recursos para
    reutilizar la imagen en caso de estar ya creada por otra entidad. 

    \item \textit{PhysicBody}: Componente encargado de crear un cuerpo físico de Box2D. Implementa la funcinalidad de sincronizar posición, rotación y escala del \texttt{Transform} de la entidad al cuerpo físico.
    Contiene la información sobre bastante propiedades físicas como el tipo de cuerpo (estático, cinemático, dinámico), el rozamiento o la escala de la gravedad. De esta clase heredan \texttt{BoxBody}, 
    \texttt{CircleBody} y \texttt{EdgeBody}, que son cuerpos físicos cuyos colisionadores tienen formas especiales.

    \item \textit{SoundEmitter}: Componente encargado de cargar un sonido e implementar métodos para reproducirlo, detenerlo, pausarlo, etc. Como se comentó anteriomente, SDLMixer dispone de un conjunto de canales
    para reproducir sonidos pero este componente es abstrae la necesidad de canales desde la perspectiva del usuario. 

    \item \textit{MusicEmitter}: Componente encargado de cargar música e implementar métodos para reproducirla, detenerla, pausarla, rebobinarla, etc.

    \item \textit{ParticleSystem}: Componente encargado de implementar un sistema de partículas configurable. Tiene soporte para cargar texturas y mover las partículas con el motor de físicas Box2D.

    \item \textit{Animation}: Componente encargado de implementar la lógica de reproducción de animaciones.

    \item \textit{TopDownController}: Componente encargado de implementar un movimiento tipo Top-Down. 

    \item \textit{PlatformController}: Componente encargado de implmentar un movimiento de tipo plataformas.

    Estos dos útlimos componentes no son fundamentales pero aportan comodidad porque evitan al usuario tener que implementarlos usando el sistema de scripting, lo que puede ser algo avanzado.

    \medskip 

    Mencionar también que es obligatorio que las entidades tengan al menos un componente, Transform u Overlay. Esto es así para poder distinguir entre entidades destinadas a la interfaz de usuario y el resto
    de entidades de la escena.

\end{itemize}

En cuanto a los managers:

\begin{itemize}
    \item \textit{SceneManager}: encargado de manejar las escenas. Para ello, cuenta con una pila en la que va almacenando las escenas que se crean. La escena que se va actualizar en el juego es la que se encuentra
    en el top de la pila. 

    \medskip
    
    Hay 5 operaciones que se pueden realizar:

    \begin{enumerate}
        \item \textit{Operación PUSH}: carga la escena y la añade al top de la pila.

        \item \textit{Operación POP}: elimina la escena en el top de la pila y avisa, a la escena por debajo del top, si la hay, que va a empezar
        a actualizarse.

        \item \textit{Operación POPANDPUSH}: realiza una operación \texttt{POP} y posteriormente una operación \texttt{PUSH}.

        \item \textit{Operación CLEARANDPUSH}: vacia la pila de escenas y añade una nueva al top de la pila que va a empezar a actualizarse.

        \item \textit{Operación CLEAR}: vacia la pila de escenas.
    \end{iteenumeratemize}

    \item \textit{SceneLoader}: Clase encargado de leer la información de la escenas creadas en el editor. A la hora de construir la entidades diferencia entre entidades con \texttt{Transform} y entidades
    con \texttt{Overlay}.

    \item \textit{PrefabsManager}: Encargado de cargar la información de los prefabs creados en el editor e implementar métodos para instanciar entidades a partir de la información de esos prefabs. Se 
    diferencia entre prefabs con \texttt{Transform} y prefabs con \texttt{Overlay}. 

    \item \textit{RenderManager}: Encargado de renderizar por orden las entidades de la escena. A la hora de desarrollar en juego es deseable poder elegir elegir el orden en el que se renderizan las 
    entidades. Esto también se conoce como profundidad o z-order.

    \item \textit{ReferencesManager}: Encargado de manejar una relación entre las entidades y sus identificadores. Necesario para evitar problemas de referencias entre entidades.
\end{itemize}


% ----------------------------------------------- PROYECTO PRINCIPAL -------------------------------------------------

\subsection{Bucle principal}

Este proyecto implementa la clase \texttt{Engine}, encargada de inicializar el motor, ejecutar su bucle principal y cerrarlo una vez terminado.

\medskip

En cuanto al bucle principal, tiene la siguiente estructura:

\begin{center}
    \includegraphics[scale=0.3]{Imagenes/Vectorial/EstructuraBuclePrincipal}
\end{center}

Además de esos métodos, se realizan cálculos de tiempo para proporcionar al usuario el \texttt{DeltaTime}, tiempo transcurrido desde el inicio de la ejecución del programa o el número de frames/actualizaciones
hasta el momento. El \texttt{DeltaTime} es una medida de tiempo, generalmente en milisegundos, que informa sobre el tiempo transcurrido entre la iteración anterior y la actual. 

\medskip

Algo a comentar es la diferencia entre el \texttt{Paso físico} y la \texttt{Actualización}. La lbrería de físicas Box2D, y todas en general, requieren que la actualización del mundo físico se realice en intervalos
de tiempo fijo, principalmente por motivos de estabilidad. Por ello, es necesario hacer cálculos adicionales para saber en que momentos se debe ejecutar el Paso Físico ya que no se puede llamar en cada frame, a 
diferencia de la \texttt{Actualización}.

\medskip

La potencia del hardware de la computadora y la carga de trabajo afectan directamente al número de actualizaciones por segundo que se producen en el bucle principal de un videojuego. Por lo tanto, la llamada al 
método \texttt{Actualización} se puede dar con mucha irregularidad. Sin embargo, el motor de física necesita intervalos de tiempo fijo.

\medskip

Esto se explica mejor con el siguiente diagrama:

\begin{center}
    \includegraphics[scale=0.3]{Imagenes/Vectorial/UpdateVsFixed}
\end{center}

Como se puede apreciar, el \texttt{Paso físico}, marcado en verde, siempre se ejecuta en el mismo intervalo de tiempo. Ese intervalo de tiempo fijo es un valor que se puede modificar en base a las necesidades
del videojuego.


\section{Cómo se genera la información necesaria para el editor}

% Reflexión

\section{Cómo funciona el scripting por nodos}



\section{Cómo se traduce un script a lógica en C++}