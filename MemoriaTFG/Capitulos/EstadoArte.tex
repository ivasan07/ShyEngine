%---------------------------------------------------------------------
%
%                          Estado del arte
%
%---------------------------------------------------------------------

\chapter{Estado del arte}
\label{cap3:estado_del_arte}

\begin{resumen}
Este capítulo se centra en los videojuegos, cómo se desarrollan, qué es un motor de videojuegos, cuáles son sus partes fundamentales, cuáles son los
más utilizados hoy en día y sus características, qué es un editor y porque se usan para el desarrollo, qué significa el scripting y las formas que 
existen para generar comportamiento en los videojuegos.
\end{resumen}

\section{Qué es un videojuego}

Un videojuego es un juego electrónico en el que uno o más jugadores interactúan mediante un controlador con un dispositivo electrónico que muestra
imágenes de video. Este dispositivo, comúnmente conocido como ``plataforma'', puede ser una computadora, una máquina de arcade, una consola de 
videojuegos o teléfono móvil, tableta o una consola de videojuegos portátil.

\medskip

Se puede entender como un programa software que es procesado por una máquina que cuenta con dispositivos de entrada y de salida. El programa contiene 
toda la información, instrucciones, imágenes y audio que componen el videojuego. Va grabado en cartuchos, discos ópticos, discos magnéticos, tarjetas de 
memoria especiales para videojuegos, o bien se descarga directamente a través de Internet.

\medskip

Típicamente, los videojuegos recrean entornos y situaciones virtuales en los que el jugador puede controlar a uno o varios personajes para conseguir
un objetivo dentro de unas reglas determinadas. Dependiendo del videojuego, una partida pueden disputarla una o varias personas contra la máquina o bien
múltiples jugadores a través de una red LAN o en línea vía Internet. El género de un videojuego se refiere a una categoría o clasificación que se utiliza
para describir su estilo, mecánicas de juego, temas y elementos característicos. Algunos de los géneros más representativos son los videojuegos de acción,
rol, estrategia, simulación, deportes o aventura.

\subsection{Cómo se hace un juego}

La creación de videojuegos es una actividad llevada a cabo por las empresas desarrolladoras de videojuegos. Estas se encargan de diseñar y programar el videojuego,
desde el concepto inicial hasta el videojuego en su versión final. Esta es una actividad multidisciplinaria, que involucra profesionales de la informática,
el diseño, el sonido, la actuación, etc. El proceso es similar a la creación de software en general, aunque difiere en la gran cantidad de aportes creativos
necesarios. El desarrollo también varía en función de la plataforma objetivo, el género y la forma de visualización (2d, 2.5d y 3d).

\medskip

El desarrollo ha pasado por muchas fases hasta el estado en el que se ecuentra en la actualidad. En las primeras décadas a partir del nacimiento de los videojuegos,
los desarrolladores tenían que diseñar hardware específico para ejecutar los juegos. A partir de la década de 2000 en adelante, la mayoría de los juegos se desarrollan
digitalmente, lo que significa que el código y los recursos se crean en computadoras en lugar de hardware dedicado.

\medskip

La idea fundamental de crear videojuegos se divide en programar el comportamiento, reglas y lógica del juego y crear los recursos (imágenes, audio, mapas, etc) que se
quiera cargar en el juego.

\medskip

Sin entrar mucho en detalle, las etapas que sigue un desarrollo profesional son las siguientes: concepto, diseño, planificación, preproducción, producción, pruebas,
distribución y mantenimiento.


\subsection{Qué es un juego dirigido por datos}

Con el concepto de videojuego como división de programación y recursos en mente, el concepto de juego dirigido por datos se refiere a la reutilización de la parte de programación
de un videojuego para hacer otros nuevos a partir de nuevos recursos, también entendidos como datos. 

\medskip

Algunos ejemplos de juegos que siguen esta filosofía son las aventuras gráficas desarrolladas por Lucasfilm Games:

\begin{figure}[t]
    \centering
    %
    \begin{SubFloat}
    {\label{fig:cap2:maniac}%
    Maniac Mansion (1987)}%
    \includegraphics[width=0.45\textwidth]%
    {Imagenes/Vectorial/maniacmansion}%
    \end{SubFloat}
    \qquad
    \begin{SubFloat}
    {\label{fig:cap2:indiana}%
    Indiana Jones and the Last Crusade: The Graphic Adventure (1989)}%
    \includegraphics[width=0.45\textwidth]%
    {Imagenes/Vectorial/indianajones}%
    \end{SubFloat}

    % Siguiente linea

    \begin{SubFloat}
    {\label{fig:cap2:loom}%
    Loom (1990)}%
    \includegraphics[width=0.45\textwidth]%
    {Imagenes/Vectorial/loom}%
    \end{SubFloat}
    \qquad
    \begin{SubFloat}
    {\label{fig:cap2:samandmax}%
    Sam and Max Hit the Road (1993)}%
    \includegraphics[width=0.45\textwidth]%
    {Imagenes/Vectorial/samandmax}%
    \end{SubFloat}

    \caption{Juegos desarrollados por Lucasfilm Games.%
    \label{fig:cap2:LucasfilmGames}}
\end{figure}

Como ejemplos de juegos clásicos dirigidos por datos serían el Quake II y el Half-Life, desarrollados por idSoftware y Valve Corporation, respectivamente.

\begin{figure}[t]
    \centering
    %
    \subfloat[][Quake II (1997)]{
    \includegraphics[width=5cm]{Imagenes/Vectorial/quake2}
    \label{fig:etiqueta1}
    }
    \qquad
    \subfloat[][Half-Life (1998)]{
    \includegraphics[width=5cm]{Imagenes/Vectorial/halflife}
    \label{fig:etiqueta2}
    }
    \caption{Ejemplos de juegos dirigidos por datos con juegos clásicos}
    \label{Etiqueta para toda la figura}
\end{figure}  

En todos ellos, se creaban nuevos datos/recursos para desarrollarlos.

\section{Qué es un motor de videojuegos}

Un motor de videojuegos es un entorno de desarrollo que proporciona herramientas para la creación de videojuegos. Su función principal es dotar al videojuego de un motor para
renderizar gráficos 2D y 3D, un motor físico que simule las leyes de la física y detección de colisiones, y herramientas para poder crear las animaciones, scripts, sonidos, 
inteligencia artificial, redes, gestión de memoria, y demás sistemas del videojuego.

\medskip

El término `motor de juego' surgió a mediados de la década de 1990 en referencia a juegos de disparos en primera persona (FPS) como el popular Doom de id Software. Doom fue 
diseñado con una separación razonablemente definida entre sus componentes de software principales (como el sistema de renderizado gráfico tridimensional, el sistema de detección
de colisiones o el sistema de audio) y los recursos artísticos, mundos de juego y reglas de juego que componían la experiencia de juego del jugador. El valor de esta separación
se hizo evidente cuando los desarrolladores comenzaron a licenciar juegos y a adaptarlos para crear nuevos productos mediante la creación de nuevos recursos artísticos, diseños 
de mundos, armas, personajes, vehículos y reglas de juego con cambios mínimos en el software del ``motor''.

\medskip

Hacia finales de la década de 1990, algunos juegos como Quake III Arena y Unreal fueron diseñados teniendo en cuenta la reutilización y la ``modificación''. Los motores se hicieron
altamente personalizables mediante lenguajes de programación de scripts como el Quake C de idSoftware, y la licencia de motores comenzó a ser una corriente de ingresos secundaria
viable para los desarrolladores que los crearon. 

\subsection{División entre motor y gameplay}

El gameplay se define como la experiencia general de jugar a un videojuego. Incluye las mecánicas, las reglas que gobiernan las interacciones entre los elementos en el juego, los
objetivos del jugador, los criterios para ganar o perder, las abilidades del personaje, los NPC (Non-Playable-Characters), y el flujo general de la experiencia de juego en su conjunto.

La línea entre un juego y su motor a menudo es borrosa. Algunos motores hacen una distinción razonablemente clara, mientras que otros apenas hacen un intento de separar los dos.

En esta imagen se representa lo que es un juego, la caja más grande, y de lo que está compuesto. Por un lado tenemos el gameplay/datos que son los recursos de imágenes, audio,
personajes, modelos, escenas, lógica y comportamiento. Y por otro lado tenemos el motor, encargado de cargar toda esa información. 

\begin{figure}[t]
\centering
    \includegraphics[width=0.9\textwidth]{Imagenes/Vectorial/Motor-Gameplay}
\caption{División de juego en motor y gameplay.%
    \label{fig:cap2:motor-gameplay}}
\end{figure}

En realidad aquí surge un problema. Los recursos obvios son imágenes y audio pero el gameplay también tiene mapas donde se colocan los elementos del juego y, sobre todo, comportamiento
que hay que crear y proporcionar al motor. Como veremos más adelante, hay varias formas de conseguir convertir en datos ese comportamiento (que en realidad es programación). 

\medskip

Otro aspecto intersante a comentar es la ``altitud'' a la que se encuentra la línea divisoria entre motor y gameplay. Si la línea está muy alta, entonces el motor nos aporta mucha funcionalidad
y hay que crear poco comportamiento en el gameplay. Eso hace que el motor esté muy focalizado en un tipo de juegos concretos por lo que si el género o tipo del videojuego a desarrollar no es
compatible con el tipo de funcionalidad que aporta el motor se va a terminar excluyendo.


\begin{figure}[t]
    \centering
        \includegraphics[scale=0.5]{Imagenes/Vectorial/MotorSobreGameplay}
    \caption{Motor aporta funcionalidad al gameplay.%
        \label{fig:cap2:motorSobreGameplay}}
\end{figure}

\medskip

De esta forma, es común encontrarse con motores pensados para géneros de videojuegos concretos. Existen motores para desarrollar videojuegos de disparos en primera persona (FPS), videojuegos
de plataformas y en tercera persona, videojuegos de lucha, videojuegos de carreras, videojuegos de estrategia en tiempo real o videojuegos multijugador online masivos, conocidos como (MMOG).

Algunos ejemplos de estos motores son Scumm, desarrollado por LucasfilmGames para sus aventuras gráficas, RPG Maker desarrollado por ASCII Corporation para juegos de rol, las primeras versiones
de Frostbite desarrollado por Electronic Arts para juegos de acción y disparos (FPS) o MUGEN desarrollado por Elecbyte para juegos de lucha en dos dimensiones.

\medskip

En el libro Game Engine Architecture de \cite{GameEngineArchitecture} se cita lo siguiente: ``Se podría argumentar que una arquitectura orientada a datos es lo que diferencia a un motor de juego
de un software que es un juego, pero no un motor. Cuando un juego contiene lógica o reglas de juego codificadas a mano, o utiliza código de casos especiales para representar tipos específicos
de objetos de juego, se vuelve difícil o imposible reutilizar ese software para crear un juego diferente. Probablemente deberíamos reservar el término `motor de juego' para el software que es
extensible y puede utilizarse como base para muchos juegos diferentes sin modificaciones importantes.''


\subsection{De que está compuesto un motor de videojuegos}

Como se ha mencionado anteriormente, un motor proporciona la tecnología necesaria para desarrollar un videojuego. Esta tecnología, en realidad, es un conjunto de varías tecnologías con diferentes
propósitos, todo necesarios para el videojuego. Para un motor de carácter general, es decir, sin implementación extra para un tipo de videojuegos concreto, estas tecnologías son las siguientes: 

\begin{itemize}
    \item \textit{Motor de renderizado}: Este componente se encarga de generar los gráficos y la representación visual del juego en la pantalla. Utiliza técnicas de renderizado, como rasterización
    o trazado de rayos, para crear la imagen final. Los motores modernos a menudo admiten efectos visuales avanzados, como sombras dinámicas, iluminación global y efectos de partículas.

    \item \textit{Motor de física}: La física es esencial para dar realismo y coherencia al juego. Este motor simula el movimiento de objetos, colisiones, gravedad y otros efectos físicos. Permite
    que los personajes y objetos del juego interactúen de manera creíble con el entorno y entre sí.

    \item \textit{Motor de audio}: Gestiona la reproducción de efectos de sonido y música en el juego. Puede incluir capacidades de mezcla de audio y efectos especiales para crear una experienciaç
    auditiva envolvente.

    \item \textit{Motor de input}: Controla la interacción del usuario con el juego a través de dispositivos de entrada como teclados, mouse, controladores de juegos o pantallas táctiles.

    \item \textit{Motor de animación}: Esto incluye la animación de personajes, la interpolación de movimientos y la gestión de esqueletos o huesos para modelar la anatomía de los personajes.

    \item \textit{Motor de red}: Facilita el juego en línea y la comunicación entre jugadores. Administra la sincronización de datos entre los clientes y el servidor, permite el chat en línea, la
    gestión de partidas y otros aspectos relacionados con la conectividad en línea.

    \item \textit{Gestor de recursos}: Garantiza que todos los posibles recursos del videojuego se carguen y descarguen de manera eficiente en memoria durante la ejecución del juego.

    \item \textit{Subsistemas de soporte}: Sistemas para iniciar y cerrar el motor, manejar la asignación de memoria, sistema de ficheros, etc.
\end{itemize}

El diagrama anterior quedaría completo de la siguiente manera:

\begin{figure}[t]
    \centering
        \includegraphics[scale=0.3]{Imagenes/Vectorial/MotorYGameplay}
    \caption{Partes fundamentales que componen un motor de videojuegos.%
        \label{fig:cap2:motorYGameplay}}
\end{figure}


\section{Qué es una arquitectura en el contexto del desarrollo de videojuegos}

Hasta ahora se hemos hablado sobre la idea de motor de videojuegos y lo que los separa del gameplay. Pero a la hora de desarrollar un videojuego existen varios patrones o arquitecturas
que se pueden seguir para construir sus bases. Estas arquitecturas definen el comportamiento del gameplay y sirven de conexión con el motor.

Un arquitectura define como se representan los diferentes tipos de entidades en el mundo junto con sus atributos y comportamientos.

Existen dos tipos de arquitecturas principales:

\begin{itemize}
    \item \textit{Centrada en objetos}: Cada objeto tiene un conjunto de atributos y comportamientos que están encapsulados dentro de la clase (o clases) de la cual el objeto es una 
    instancia. El mundo del juego es simplemente una colección de objetos del juego.

    \item \textit{Centrada en propiedades}: Cada objeto tiene un identificador y un conjunto de propiedades asociadas a ese identificador. El comportamiento de un objeto del juego se 
    define de forma implícita por la colección de propiedades de las que está compuesto.
\end{itemize}

Aquí una imagen que muestra la diferencia:

\begin{figure}[t]
    \centering
        \includegraphics[scale=0.3]{Imagenes/Vectorial/ObjetosvsPropiedades}
    \caption{Diferencia entre arquitectura centrada en objetos vs propiedades.%
        \label{fig:cap2:objetosvspropiedades}}
\end{figure}



\subsection{En qué consiste la arquitectura basada en Entidades y Componentes (EC)?}

La arquitectura basada en entidades y componentes (EC) es un enfoque fundamental en el desarrollo de videojuegos debido a su flexibilidad y eficiencia en el manejo de la complejidad. Esta basado en la idea de arquitectura centrada en propiedades.

En el corazón de la arquitectura EC se encuentran dos conceptos clave:

\begin{itemize}
  \item \textit{Entidades}: Una entidad representa un objeto individual en el juego. Esto podrí­a ser cualquier cosa, desde un personaje, un enemigo, un proyectil, hasta un objeto inanimado como una piedra pero realmente contenedores vací­os que no contienen lógica ni información por sí­ mismos y lo que les define son sus componentes.

  \item \textit{Componentes}: Los componentes son módulos independientes que contienen datos y lógica específica de una entidad. Cada entidad en un juego está compuesta por uno o más componentes que definen sus atributos y comportamiento. Por ejemplo, una entidad de jugador podrí­a tener componentes como ``Posición'' para representar su ubicación en el mundo, ``Imagen'' para la apariencia visual o ``Movimiento'' (para el movimiento del personaje), entre otros.

\end{itemize}

La principal ventaja de esta separación entre entidades y componentes es que permite una gran flexibilidad y reutilización de código. Las entidades pueden ser construidas y modificadas dinámicamente combinando diferentes componentes. Esto facilita la creación de nuevos tipos de objetos en el juego sin necesidad de escribir código especí­fico para cada uno.

\subsection{Qué es una arquitectura basada en herencia?}

La arquitectura basada en herencia ha sido un enfoque tradicional en el desarrollo de videojuegos y todaví­a se utiliza en algunos motores y sistemas. Este enfoque se centra en la creación de jerarquí­as de clases en las que cada clase representa un tipo de objeto en el juego. Por ejemplo, si está creando un juego de rol (RPG), se podría tener una jerarquí­a de clases que comienza con una clase base ``Personaje'' y se divide en clases derivadas como ``Jugador'' y ``Enemigo''. Cada clase puede agregar o modificar atributos y métodos según sea necesario.

\medskip

La arquitectura basada en herencia presenta ciertas ventajas, especialmente en proyectos más pequeños o simples. Una de las ventajas clave es su simplicidad conceptual, ya que la herencia permite establecer relaciones claras entre clases a través de una jerarquía. Además, en situaciones donde se requiere un alto rendimiento, la herencia puede ser más eficiente, ya que las clases son estáticas y el compilador puede realizar optimizaciones específicas.

\medskip
Sin embargo, esta arquitectura también tiene sus desventajas. Uno de los problemas más significativos es su rigidez. La herencia puede hacer que un sistema sea menos adaptable a cambios o que la creación de nuevas clases sea más complicada, ya que cualquier modificación en la clase base puede afectar a todas las clases derivadas. En proyectos grandes, las jerarquías de clases pueden volverse extremadamente complejas y difíciles de mantener, lo que puede aumentar la complejidad y el tiempo de desarrollo. Además, compartir funcionalidad entre clases no relacionadas en la jerarquía puede ser complicado, lo que dificulta la reutilización de código.

\section{¿Qué es un editor?}
\label{cap3:sec:motores}

Un editor de videojuegos es una herramienta de software diseñada para facilitar la creación, diseño y modificación de videojuegos. A lo largo de la historia de los videojuegos, los editores han evolucionado significativamente en términos de funcionalidad y facilidad de uso. 

\subsection{Evolución histórica de los Editores}

En sus inicios, los editores de videojuegos eran herramientas rudimentarias que requerían un conocimiento técnico profundo y estaban reservados principalmente para desarrolladores de juegos experimentados. Estos primeros editores solían centrarse en la manipulación de código y la creación de niveles o mapas, con una interfaz de usuario limitada.

\medskip

Con el tiempo, a medida que la industria de los videojuegos creció y se diversificó, los editores se volvieron más accesibles y versátiles. Surgieron soluciones más amigables para el usuario que permitían a diseñadores, artistas y creadores de contenido participar en el proceso de desarrollo de juegos sin necesidad de habilidades de programación avanzadas.

\subsection{Importancia en el desarrollo de videojuegos}

Los editores de videojuegos desempeñan un papel crucial en el proceso de desarrollo de un videojuego. Estas herramientas permiten a los desarrolladores:

\begin{enumerate}
    \item \textit{Diseñar Niveles y Escenarios}: Los editores permiten la creación y edición de entornos, niveles y escenarios. Los diseñadores pueden colocar objetos, enemigos, obstáculos y elementos interactivos en el mundo del juego.

    \item \textit{Gestionar Recursos}: Los editores proporcionan una plataforma para administrar recursos del juego, como imágenes, sonidos, modelos 3D y más. Los recursos se organizan y se pueden vincular a elementos del juego.

    \item \textit{Definir Comportamientos}: Los editores modernos permiten definir comportamientos de personajes y objetos mediante sistemas visuales de programación o scripts. Esto facilita la creación de interacciones y mecánicas de juego.

    \item \textit{Simular y Depurar}: Los editores a menudo incluyen herramientas de simulación y depuración que ayudan a los desarrolladores a probar y solucionar problemas en tiempo real.
\end{enumerate}

\subsection{Enfoque histórico y actual de la integración entre editor y motor}

En la actualidad, muchos editores de videojuegos están integrados con motores de juego, una evolución significativa con respecto a la forma en que solían operar por separado. Antes, los motores y los editores solían ser herramientas independientes, lo que requería a los desarrolladores crear contenido en el editor y luego importarlo y vincularlo manualmente al motor. Este proceso a menudo era laborioso y propenso a errores.

\medskip 

Un ejemplo histórico de esta separación entre motores y editores es el caso de WorldCraft, una herramienta de diseño de niveles utilizada por Valve para desarrollar juegos como ``Half-Life''. En ese entorno, los diseñadores creaban mapas y niveles en WorldCraft, pero luego necesitaban compilar esos niveles en un formato que el motor del juego pudiera entender. Este proceso de compilación a menudo llevaba tiempo y podía ser complicado, lo que requería una comprensión profunda de ambas herramientas. En la imagen \ref{fig:Worldcraft} observamos el editor WorldCraft.

\medskip

Sin embargo, con la integración de editores y motores en la actualidad, este proceso se ha simplificado significativamente. El motor y el editor trabajan en conjunto de manera más fluida, lo que permite a los desarrolladores diseñar niveles, crear contenido y ajustar parámetros directamente en el editor. La comunicación entre el editor y el motor es más directa, lo que significa que los cambios realizados en el editor se reflejan de manera más inmediata en el juego. Por ejemplo, un diseñador puede usar el editor para colocar entidades en el mapa, definir sus atributos y comportamientos, y estos cambios se aplican sin necesidad de complicados procesos de compilación.

\medskip 

Esta integración ha mejorado significativamente la eficiencia y la productividad en el desarrollo de videojuegos, permitiendo a los equipos de desarrollo centrarse más en la creatividad y la iteración rápida. La simplicidad de este enfoque también ha abierto las puertas a diseñadores y creadores de contenido que pueden contribuir al desarrollo de juegos sin necesidad de conocimientos profundos en programación o procesos de compilación.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{Imagenes/Vectorial/Worldcraft}
    \caption{Editor de WorldCraft.}
    \label{fig:Worldcraft}
\end{figure}
\medskip 

\subsection{TODO: COMUNICACION MOTOR-EDITOR (NO ENTIENDO EL COMENTARIO DE PP)}



% --------------------------------------------------------- SCRIPTING -------------------------------


\section{¿Qué es el Scripting?}

El scripting, en el contexto del desarrollo de videojuegos, se refiere a la capacidad de definir el comportamiento y las reglas del juego utilizando scripts o instrucciones escritas en un lenguaje específico. Estos scripts permiten controlar eventos, acciones y la interacción dentro del juego, proporcionando una forma versátil de diseñar la experiencia del jugador.

\subsection{¿Como se convierte el comportamiento en datos para el motor?}

Una pregunta esencial en el desarrollo de videojuegos es cómo traducir el comportamiento deseado del juego en información que el motor del juego pueda procesar. La manera en que esto se logra depende en gran medida de cómo esté estructurado el motor y del diseño del juego en sí.

\medskip 

Si el motor del juego está diseñado para ser muy específico y limitado en cuanto a la personalización, es posible que no sea necesario programar comportamientos adicionales. Por ejemplo, en las expansiones de Los Sims, gran parte del comportamiento ya está incorporado en el motor del juego, y los datos simplemente se utilizan para ajustar y personalizar ese comportamiento existente. En este caso, el diseñador trabaja dentro de las restricciones del motor existente y utiliza los datos para modificar cómo se comportan las entidades del juego.

\medskip 

En contraste, si el motor no está diseñado para ser tan específico y se requiere agregar comportamientos particulares, entonces es necesario recurrir a la programación. Es aquí donde se pueden dar distintos enfoques:

\begin{enumerate}
    \item Un enfoque común en esta situación es el uso de Dynamic Link Libraries (DLL) o bibliotecas de enlace dinámico. Aquí, losprogramadores escriben código en lenguajes como C++ para definir nuevos comportamientos o características del juego. Estoscomportamientos se agrupan en bibliotecas (DLL) que se integran con el motor del juego.

    \medskip 

    La clave del funcionamiento de las DLL es el enlace dinámico. En lugar de incluir todo el código de la DLL en el ejecutabledel juego, el programa principal solo contiene referencias a las funciones y datos en la DLL. Estas referencias se resuelvenen tiempo de ejecución cuando el juego se carga. Esto significa que las DLL se cargan en memoria solo cuando se necesitan, loque ahorra recursos y permite una gestión más eficiente de la memoria. Sin embargo, es necesario implementar un sistema de reflexión y serialización/deserialización en el motor del juego, ya que esto permite agregar nuevas entidades ocomportamientos sin necesidad de recompilar o modificar el código del motor. 

    \medskip 

    Este enfoque de DLLs ha sido ampliamente utilizado en motores de juego como Unreal Engine, lo que ha contribuido a su éxito enla  industria del desarrollo de videojuegos. Además, también se empleó en juegos icónicos como Quake II y Half-Life.


    \item Otra alternativa importante es el uso de ``programación no nativa'' mediante el empleo de lenguajes de script. Unejemplo clásico de esto es el uso de Lua. Lua es un lenguaje de script que se interpreta, lo que significa que para el motordel juego es simplemente un archivo de texto que contiene instrucciones.

    \medskip 

    Este enfoque tiene varias ventajas. Primero, permite iteraciones rápidas en el desarrollo, ya que no es necesario recompilartodo. Además, no se requiere un entorno de desarrollo costoso como Visual Studio para programar el gameplay, lo que reduce loscostos y las barreras de entrada para los desarrolladores.

    \medskip

    En la figura \ref{fig:dll} se observa de manera esquemática el funcionamiento de una DLL.
    
    \medskip 

    Sin embargo, este enfoque también presenta desafíos. Se necesita una conexión efectiva entre el mundo nativo (generalmenteescrito en lenguajes como C++) y el lenguaje de script para que puedan comunicarse y llamar funciones entre sí. 
    
    \medskip 

    A cambio, como todo se maneja como datos, la parte de reflexión se vuelve más sencilla para la serialización y la interaccióncon el editor del juego. Esto significa que los comportamientos y características definidos en lenguajes de script suelen sermás accesibles y configurables en el editor del juego sin necesidad de recompilar el motor. 
    
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{Imagenes/Vectorial/DLL.png}
    \caption{Funcionamiento de una DLL.}
    \label{fig:dll}
\end{figure}

Por supuesto, también es importante considerar las limitaciones y desafíos que los lenguajes de script pueden presentar. Aunque son poderosos en muchos aspectos, pueden resultar complicados para los diseñadores de juegos y, en algunos casos, pueden volverse muy verbosos dependiendo de los objetivos específicos. Una posible solución es la programación visual.

\subsubsection*{Programación visual}
\label{programacionVisual}

La programación visual es una alternativa que busca hacer que la creación de comportamientos y características del juego sea más accesible para los diseñadores. En lugar de escribir líneas de código, los diseñadores pueden utilizar interfaces gráficas y elementos visuales para definir y configurar el comportamiento del juego. Esto hace que el proceso sea más intuitivo y menos dependiente de conocimientos de programación.

\medskip 

En este enfoque, lo que se crea visualmente se traduce aún en datos que el motor del juego puede entender. Estos datos pueden interpretarse de diversas formas. Por ejemplo, se pueden transpilar a código C++, lo que finalmente nos llevaría de nuevo al primer enfoque que mencionamos. También podrían reescribirse en un lenguaje de script como Lua, o simplemente serializarse en un formato propio y luego ejecutarse mediante un intérprete diseñado específicamente para ese formato.


\subsection{¿Como se comunica el motor con el scripting?}
\label{comunicacionScripting}

La interacción entre el motor del juego y el sistema de scripting en lo que respecta al gameplay es una consideración central en el proceso de desarrollo de videojuegos en tiempo real. Dado que el motor del juego conoce  los eventos que suceden en el juego, como el fin de una partida o colisiones entre entidades, surge la interrogante de cómo las entidades del juego adquieren conocimiento de estos eventos. En este contexto, se emplean principalmente dos enfoques: el sistema de eventos y el método de encuestas:

\begin{itemize}
    \item \textit{Eventos}: El sistema de eventos podría dividirse en tres partes:
        \begin{enumerate}
            \item \textit{Generación de eventos}: El motor del juego genera eventos cuando ocurren acciones o situaciones relevantes en el juego. Estos eventos pueden ser muy variados y pueden incluir cosas como colisiones entre objetos, la finalización de una partida, la recolección de un objeto, etc.

            \item \textit{Registro de eventos}: Las entidades del juego pueden registrarse para escuchar eventos específicos. Por ejemplo, un personaje podría registrarse para recibir un evento cuando colisiona con un enemigo.

            \item \textit{Manejadores de eventos}: Cuando se produce un evento, el motor del juego busca a todas las entidades registradas que estén interesadas en ese evento particular y llama a los manejadores de eventos correspondientes en esas entidades. Estos manejadores de eventos son funciones que se ejecutan para reaccionar al evento de una manera determinada.
        \end{enumerate}

    \item \textit{Encuestas}: El método de encuestas implica que las entidades del juego consulten activamente el estado del juego y los eventos relevantes en lugar de esperar a ser notificadas de ellos. En este enfoque, cada entidad del juego, de manera periódica o en respuesta a ciertos eventos de tiempo, realiza una encuesta o consulta al estado actual del juego, y reacciona en base a ello.

    Si bien este método puede ser más simple de implementar en algunos casos, puede resultar en un mayor uso de recursos de CPU ya que las entidades deben realizar encuestas continuas, incluso si no hay eventos relevantes en ese momento.

\end{itemize}


% --------------------------------------------------------- EJEMPLOS DE MOTORES -------------------------------

\section{Ejemplos de motores}

\subsection{Unity}

Unity es ampliamente reconocido como uno de los motores de videojuegos más populares y versátiles en la industria actual, que fue lanzado en 2005 por Unity Technologies Lo que distingue a Unity separación intermedia entre gameplay y motor, que permite desarrollar una amplia variedad de videojuegos, desde simples juegos móviles 2D hasta experiencias de realidad virtual inmersivas para múltiples plataformas, incluyendo PC, consolas y dispositivos móviles.

\subsubsection{Arquitectura}

En términos de su arquitectura, Unity adopta una estructura que se alinea con la arquitectura basada en Entidades y Componentes (EC). En este enfoque, los elementos fundamentales son los ``GameObjects'', que funcionan como las entidades en el mundo del juego. Cada ``GameObject'' puede estar compuesto por una combinación de ``componentes'', que actúan como los módulos responsables de definir su comportamiento y características.

\medskip

La familiaridad con esta arquitectura es evidente desde el propio editor de Unity. El proceso de desarrollo se basa en la creación de entidades (GameObjects) y la asignación de scripts (componentes) para otorgar funcionalidad al juego. Estos scripts, escritos principalmente en C\#, permiten definir cómo interactúan y responden los GameObjects en el mundo del juego.

\medskip

Unity utiliza varios lenguajes de programación. Para componentes de alto rendimiento, como el motor de física, utiliza C++.
Para el desarrollo de scripts y el propio editor, utiliza C\#.

\subsubsection{Scripting}

El sistema de scripting de Unity se basa en C\# y hace uso fundamentalmente del componente \texttt{MonoBehaviour}. \texttt{MonoBehaviour} es una clase que todos los scripts en Unity deben heredar para funcionar como componentes adjuntos a objetos en el juego. Significa que cualquier script destinado a ser un componente en un GameObject debe ser una subclase de \texttt{MonoBehaviour}. Esta herencia permite que Unity comprenda y gestione adecuadamente los scripts como parte integral de la lógica del juego.

\medskip

En la imagen \ref{fig:unityEditor} podemos ver el editor de Unity.


\subsubsection{Comunicación motor-editor}

TODO

TODO: HABLAR DE HOT-RELOAD?

\begin{figure}[t]
    \centering
        \includegraphics[scale=0.15]{Imagenes/Vectorial/UnityEditor}
    \caption{Editor de Unity.%
        \label{fig:unityEditor}}
\end{figure}

\subsection{Unreal}

Unreal Engine es un motor de videojuegos desarrollado por Epic Games. Apareció por primera vez en 1998 con el videojuego de disparos en primera persona Unreal y actualmente se encuentra en la versión 5.3. Está escrito en C++ 
y es multiplataforma. En cuanto a la ´´altitud'' de la línea de separación entre motor y gameplay, UnrealEngine ofrece bastante pero no por ello lo convierte en un motor pensado para un tipo de videojuegos concreto. De hecho, 
aporta tanta funcionalidad que se considera de propósito general. Es tan potente que además de videojuegos, con Unreal se puede hacer simulación, diseño de automóviles, arquitectura, e incluso vídeos y películas.


\medskip 

En cuanto al editor, tiene el siguiente aspecto:

\begin{figure}[t]
    \centering
        \includegraphics[scale=0.2]{Imagenes/Vectorial/unrealeditor}
    \caption{Editor de Unreal Engine.%
        \label{fig:cap2:unrealeditor}}
\end{figure}

\subsubsection{Arquitectura}

La arquitectura de gameplay en Unreal Engine es una mezcla de componentes y herencia. El motor utiliza una combinación de herencia de clases y la composición de componentes para crear objetos y personajes en el mundo del juego.

En cuanto a la herencia de clases, Unreal Engine utiliza la herencia de clases para crear una jerarquía de objetos y personajes. Por ejemplo, puedes tener una clase base que representa un personaje jugable y luego crear subclases que hereden de la clase base para crear personajes específicos con características adicionales. Esto permite la reutilización de código y la organización de la funcionalidad común.

Además de la herencia de clases, Unreal Engine hace un uso extensivo de la composición de componentes. Los componentes son módulos independientes que se adjuntan a los actores (objetos y personajes) para proporcionar funcionalidad adicional. Por ejemplo, un personaje jugable puede tener componentes para la cámara, el control de movimiento, la colisión y la animación. Los componentes se pueden agregar y eliminar de manera flexible para personalizar el comportamiento de los actores sin necesidad de crear nuevas clases.

Por otra parte, Unreal Engine cuenta con los Blueprints, que permiten definir la lógica y el comportamiento de los actores y componentes de una manera visual y gráfica. Esto significa que puedes definir cómo interactúan los componentes y actores a través de conexiones visuales en lugar de escribir código. Los Blueprints se pueden utilizar tanto para heredar comportamientos como para agregar componentes y personalizarlos.

\subsubsection{Sistema de scripting}

En cuanto al scripting, Unreal Engine tiene dos modos distintos pero compatibles:

\begin{itemize}
    \item \textit{Programación en C++}: esta forma de scripting permite a los desarrolladores escribir código en C++ para crear la lógica del juego, personalizar el comportamiento de los actores y desarrollar características específicas. Esta opción es ideal para tareas que requieren un alto rendimiento o una manipulación más detallada de los sistemas del motor. También es cierto que la programación en C++ puede ser más compleja que el uso de Blueprints, especialmente para quienes no están familiarizados con el lenguaje.

    \item \textit{Blueprints}: son una herramienta visual que permite a los desarrolladores crear la lógica del juego sin necesidad de programar en C++. Este scripting es de tipo node-based (basado en nodos) y funciona con la unión de nodos y a través de la creación flujo y lógica. Por ello, se pueden crear prototipos rápidamente y no requieren de conocimientos de programación para utilizarlos.
\end{itemize}

En cuanto a la combinación de ambos enfoques, Unreal Engine permite integrar fácilmente código C++ y Blueprints en un mismo proyecto. Esto significa que puedes utilizar C++ para las partes críticas del rendimiento o para implementar sistemas complejos, mientras que utilizas Blueprints para prototipos rápidos, lógica de juego simple y personalización de componentes y actores. Los Blueprints también pueden comunicarse con código C++ a través de interfaces definidas, lo que permite una colaboración eficaz entre programadores y diseñadores.

\subsubsection{Comunicación motor-editor}

En este apartado debemos diferenciar de los elementos, escenas, personajes y todo lo que se pueda crear en el editor de Unreal Engine con los Blueprints.

En el primer caso, la información del editor se almacena en archivos de nivel (.umap) que contienen información sobre la ubicación de los elementos, las configuraciones de iluminación, las cámaras y más. Posteriormente, en tiempo de carga, qué sucede antes de la ejecución, Unreal Engine lee el archivo de nivel correspondiente. Este proceso implica cargar recursos desde disco, configurar la jerarquía del nivel y preparar la representación en memoria de los objetos y elementos del nivel. Por último

En el segundo caso, los Blueprints en Unreal Engine generan código C++. Cuando se ejecuta el juego o la simulación en Unreal Engine, el motor utiliza este código C++ generado a partir de los Blueprints para ejecutar la lógica de juego. Esto significa que el motor puede interpretar y ejecutar los Blueprints de la misma manera que ejecutaría código C++ escrito manualmente.

