%---------------------------------------------------------------------
%
%                          Editor
%
%---------------------------------------------------------------------

\chapter{Editor}

\section{Funcionamiento y arquitectura}
\label{arquitecturaEditor}

El editor está desarrollado en C++ a pesar de no tener el motor integrado debido a la elección de utilizar ImGUI \cite{ImGui}, una biblioteca de interfaz de usuario (UI) diseñada específicamente para C++. Esta elección nos brindó acceso a una amplia gama de funcionalidades esenciales para la creación del editor, como la creación de ventanas, dropdowns o checkboxes, entre otras.

\medskip

En la imagen \ref{fig:capturaEditor} podemos ver una imagen de nuestro editor.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{Imagenes/Vectorial/capturaEditor.png}
    \caption{Captura del editor de ShyEngine.}
    \label{fig:capturaEditor}
\end{figure}


\medskip

En cuanto a su funcionamiento, el editor se compone de tres secciones principales:

\begin{enumerate}
    \item \textit{Gestor de proyectos}: Esta sección es la primera en iniciarse y se encarga de crear un archivo de configuración ``.shyproject'' y un directorio dedicado para cada videojuego que se desee crear, o para cargar un proyecto mediante la lectura de su archivo de configuración.
    
    \item \textit{Ventana de edición de scripts}: Desde esta ventana se maneja la creación y edición de scripts. Permite a los desarrolladores definir el comportamiento y la lógica del juego.
    
    \item \textit{Editor principal}: El núcleo del editor es esta sección, donde se lleva a cabo la mayoría de la creación y edición de contenido. Aquí se manejan las entidades, la jerarquía, los componentes y los assets del juego.
\end{enumerate}

El flujo de trabajo del editor comienza con la ventana del gestor de proyectos. Después se traslada a una pila de estados, que determina qué ventana se debe mostrar y manejar en un momento dado, ya sea la ventana de edición de scripts o el editor principal.
Todas las operaciones en el editor se gestionan a través de un bucle principal que se encarga de manejar la entrada del usuario, actualizar el estado de las ventanas y renderizarlas.

\medskip

En el dibujo \ref{fig:funcionamientoEditor} podemos ver dicho flujo.

\medskip

En cuanto al funcionamiento de las ventanas, cada ventana del editor hereda de una clase padre que proporciona el funcionamiento básico necesario en ImGUI y que sirve como base para definir el comportamiento específico de cada ventana de la escena.

\medskip 

El editor cuenta con varias ventanas principales:

\begin{itemize}
    \item \textit{Scene}: Esta ventana es en la que se previsualizan todas las entidades de la escena.
    
    \item \textit{Hierarchy}: En esta ventana se puede ver un listado de todas las entidades que contiene la escena, así como permite gestionar la jerarquía entre ellas.
    
    \item \textit{Components}: Desde esta ventana se puede visualizar, modificar, y añadir componentes y scripts a las entidades.

    \item \textit{File Explorer}: Esta ventana permite navegar por los directorios de nuestro proyecto para ver y manejar nuestros assets, y realizar acciones como cargar una escena guardada.
\end{itemize}

Aunque también dispone de otras ventanas secundarias como la de preferencias, la de gestión de prefabs, la de edición de la paleta de colores, o la consola.

\medskip

En el dibujo \ref{fig:arquitecturaVentanas} observamos esta arquitectura de ventanas.

\medskip

Cabe destacar que el editor también soporta la modificación del layout de ventanas y personalización de la paleta de colores, como se ve en la imagen \ref{personalizacionEditor}.

\medskip

En relación a la gestión de entidades, cada una de ellas se identifica mediante un ID único. Este ID desempeña un papel crucial al permitir la distinción entre las distintas entidades y se utiliza, por ejemplo, para referenciarlas en scripts. Además, cada entidad puede contener una referencia a su entidad padre o a sus entidades hijas, en caso de que existan relaciones jerárquicas.
\medskip

Un aspecto importante del sistema de IDs es que también se utiliza para diferenciar las entidades normales de los prefabs. Los prefabs se distinguen por tener un ID negativo, lo que les permite ser identificados de manera única.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{Imagenes/Vectorial/FuncionamientoEditor.png}
    \caption{Flujo de funcionamiento del editor.}
    \label{fig:funcionamientoEditor}
\end{figure}


\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{Imagenes/Vectorial/ArquitecturaVentanas.png}
    \caption{Arquitectura de las ventanas.}
    \label{fig:arquitecturaVentanas}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{Imagenes/Vectorial/personalizacionEditor.png}
    \caption{Personalización del editor.}
    \label{fig:funcionamientoEditor}
\end{figure}

\section{Como se leen los componentes a partir de los datos del motor}
Como se mencionó anteriormente en \ref{generacionDeDatos}, el motor del juego genera archivos en formato JSON que contienen los datos serializados de los componentes, sus atributos y su tipo correspondiente.

\medskip

Los datos en formato JSON se interpretan y se utilizan para construir objetos de C++ en el editor. Estos objetos son los que se añaden a las entidades para definir su comportamiento.

\medskip

En la imagen \ref{fig:datosEditor} se puede observar el funcionamiento de la lectura de componentes.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{Imagenes/Vectorial/LecturaComponentesEditor.png}
    \caption{Lectura de componentes del motor en el editor.}
    \label{fig:datosEditor}
\end{figure}


\section{Como se trasladan los datos del editor al motor} 

Una vez creado el juego, llega la parte de pasarle toda la información al motor. Para ello, se serializa toda la información relativa  a la escena, como su nombre y sus entidades, en un formato JSON que luego el motor se encargará de interpretar, como se menciona en \ref{managersycomponentes}.

\medskip

Cabe destacar que hay información como las preferencias o las entidades que son prefabs se serializan en el archivo ``.shyproject'' (de igual manera que con la escena), ya que son elementos del proyecto y no de una escena en concreto.

\medskip

La figura \ref{fig:serializacionEditor} representa como se serializa la información que será trasladada al motor.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{Imagenes/Vectorial/SerializacionEditor.png}
    \caption{Serialización de la información del juego.}
    \label{fig:serializacionEditor}
\end{figure}

\section{Scripting en el editor}
\label{scriptingEditor}

Como hemos mencionado anteriormente, el editor contiene un estado completamente dedicado a la creación y modificación de scripts. 

\medskip

En el editor, los scripts se crean utilizando un sistema de programación visual [\ref{programacionVisual}] mediante nodos y conexiones. Los nodos representan acciones o eventos [\ref{comunicacionScripting}] específicos que ocurren en el juego, como el inicio de una escena, la colisión entre objetos o la activación de una trampa. Estos nodos se organizan en el espacio de trabajo del editor y se conectan entre sí para definir la secuencia y lógica del comportamiento.

\medskip

Por ejemplo, un nodo de evento podría desencadenar una secuencia de nodos de lógica que determinan cómo responde el juego cuando un jugador alcanza cierta puntuación. Los nodos de valores se utilizan para almacenar y manipular datos dentro del script, lo que permite a los desarrolladores realizar cálculos y tomar decisiones basadas en variables específicas.

\medskip

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{Imagenes/Vectorial/ejemploScripting.png}
    \caption{Ejemplo de scripting en el editor.}
    \label{fig:ejemploScripting}
\end{figure}

La mejor manera de entender esto es con la figura \ref{fig:ejemploScripting}. En dicha figura observamos el nodo del evento \texttt{Update}, que se lanza una vez por frame. Este nodo tiene una flecha de flujo hasta el nodo \texttt{SetLinearVelocity}, que recibe como parametro de entrada otros dos nodos: la entidad y la velocidad en el eje X que se quiere aplicar. A su vez, esta velocidad proviene de una multiplicación de dos nodos de tipo númerico. Como se puede apreciar, la entrada y salida de datos viene representada con una flecha mas fina que la de flujo.

\subsection{Serialización y uso en el motor}

El flujo de nodos y conexiones en el editor es una representación visual de un script, pero esta información debe serializarse en un formato que el motor del juego pueda entender y ejecutar. Para lograr esto, el editor guarda el script en un archivo en formato JSON. Este archivo contiene toda la información sobre los nodos, conexiones y sus propiedades asociadas. Mencionar también que en la serialización de las entidades, estás contienen información sobre que scripts tienen asignado.

\medskip

Cuando un juego se ejecuta utilizando el motor, este archivo JSON se interpreta y se utiliza para guiar el comportamiento del juego. Los nodos y las conexiones se transforman en acciones y eventos en tiempo real, lo que permite que el juego responda a las interacciones del jugador y otros eventos del juego de acuerdo con el script creado en el editor.

\subsection{Edición de scripts}

Además de crear nuevos scripts, el editor también permite la modificación de scripts existentes. Para ello, realiza una lectura e interpretación de los JSON mencionados anteriormente de manera similar a como hacen los componentes.


\section{Ejecución del juego y generación de una build}

Una funcionalidad a destacar del editor es la posibilidad de ejecutar el juego desde este en otra ventana. Esto se realiza ejecutando el ``.exe'' del motor mediante manejadores de procesos de Windows, para poder pararlo desde el editor y evitar varios procesos del juego simultáneamente, así como redirigir la salida del juego a la consola del editor. Además tambien se puede generar una build ejecutable del juego mediante el uso de un hilo. Para ello, se agrupan todos los assets del juego, junto con el ``.exe'' (con su correspondiente nombre e icono aportados por el usuario) y los ficheros de configuración del juego generados por el editor. Esto permite a los desarrolladores crear una versión independiente del juego que puede ser distribuida y ejecutada por los usuarios finales.  

%------------------------------------------------  --------------------------------------------


