%---------------------------------------------------------------------
%
%                          Motor
%
%---------------------------------------------------------------------

\chapter{Motor}

\section{Funcionamiento y partes del motor}

El motor esta dividido en diez partes fundamentales. A continuación se entrará en detalle sobre la función y detalles de implementación de cada una y de las librerías utilizadas.

Como introducción, en la figura \ref{fig:arquitecturaMotor} se muestra una diagrama resumido sobre la arquitectura del motor.

\begin{figure}[h]
    \centering
        \includegraphics[width=13cm]{Imagenes/Vectorial/ArquitecturaMotor}
    \caption{Arquitectura del motor.
        \label{fig:arquitecturaMotor}}
\end{figure}



% ----------------------------------------------- CONSOLA -------------------------------------------------

\subsection{Consola}

Este proyecto contiene una sola clase Output con métodos estáticos que implementan funcionalidad relacionada con el mostrado de la salida estándar por la consola. Tiene métodos para imprimir texto estándar, advertencias o errores. Estos textos se diferencian por su color y sirven principalmente como ayuda para el desarrollo de un videojuego.

El motor, llamado ShyEngine, esta dividido en diez partes y cada una cumple una función específica.
A continuación se entrará en detalle sobre la función y detalles de implementación de cada proyecto y de las librerías asociadas al mismo, si las tiene.




% ----------------------------------------------- UTILIDADES -------------------------------------------------

\subsection{Utilidades}

El objetivo de este proyecto es implementar código común que pueden necesitar el resto  de proyectos evitando así la duplicación de código innecesaria.
Contiene clases tanto orientadas a guardar información como a implementar lógica y funcionalidad.

\medskip

Unos ejemplos de estas clases serían:

\begin{itemize}

    \item \texttt{Vector2D}: Representa un vector bidimensional, contiene información de dos componentes e implementa muchas de sus operaciones básicas. 
    
    \item \texttt{Random}: Contiene métodos estáticos útiles para calcular aleatoriedad entre números enteros, números reales, ángulos, y colores. 
    
    \item \texttt{Color}: Representa un color de tres canales (Red, Green, Blue) además de métodos con algo de funcionalidad como \texttt{Lerp}, que calcula
    un color intermedio entre otros dos dados.
    
    \item \texttt{Singleton}: Una plantilla para crear instancias estáticas a través de herencia. Es decir, en caso de querer convertir una clase en un 
    \texttt{Singleton}, muy útiles para managers, simplemente hay que heredar de esta clase  para conseguirlo. 
    
\end{itemize}

% ----------------------------------------------- CONSOLA -------------------------------------------------

\subsection{Consola}

Este proyecto contiene una sola clase Output con métodos estáticos que implementan funcionalidad relacionada con el mostrado de la salida estándar por la consola. Tiene métodos para imprimir texto estándar, advertencias o errores. Estos textos se diferencian por su color y sirven principalmente como ayuda para el desarrollo de un videojuego.


% ----------------------------------------------- RECURSOS -------------------------------------------------

\subsection{Recursos}

El objetivo de este proyecto es proporcionar un contenedor de recursos en el que se van a guardar todos los recursos del videojuego. En concreto, el tipo de
recursos que se pueden guardar son fuentes de texto, imágenes, efectos de sonido y música.

\medskip

Uno de los objetivos del manager de recursos es reutilizar los recursos creados para solo tener cargada una copia de cada recurso en
memoria. Por ello, a la hora de añadir un nuevo recurso al manager, primero comprueba si ya lo contiene y en ese caso, lo devuelve; en caso contrario, lo crea.




% ----------------------------------------------- SONIDO -------------------------------------------------

\subsection{Sonido}

El objetivo de este proyecto es construir un envoltorio sobre la librería de audio SDL\_Mixer para poder implementar posteriormente los componentes de emisión de música y de sonidos.

\medskip

Para un mejor entendimiento de la implementación es necesario saber que SDL\_Mixer diferencia entre efectos de sonido o sonidos cortos en general (WAV, MP3)
y música de fondo (WAV, MP3, OGG).

\medskip

Para la música, la librería solo cuenta con un canal de reproducción por lo que es algo limitado pero simple a la vez ya que no hay que lidiar con el número de canales, 
al contrario que con los efectos de sonido.

\medskip

Este proyecto cuenta con tres clases para representar y manejar sonidos:

\begin{itemize}

\item \texttt{SoundEffect}: Representa un efecto de sonido y contiene un identificador para diferenciado de otro sonidos.

\item \texttt{MusicEffect}: Representa un sonido de música de fondo. Al igual que \texttt{SoundEffect}, contiene un identificador para diferenciarse.

\item \texttt{SoundManager}: Manager \texttt{Singleton} encargado de implementar las funciones principales para reproducir, parar,
y detener sonidos, entre otros. También métodos destinados al usuario para modificar el volumen general y cambiar el número de canales disponibles para la reproducción
de efectos de sonidos.

\end{itemize}



% ----------------------------------------------- INPUT -------------------------------------------------

\subsection{Input}

Este proyecto tiene como objetivo implementar un manager, también \texttt{Singleton}, que contendrá la información del estado de las teclas/botones de los dispositivos de
entrada. En concreto, cuenta con soporte para teclado, ratón y mando.

\medskip

En el manager, las teclas/botones pueden pasar por diferentes estados los cuales se establecen al recibir determinados
eventos.

\medskip

Estos estados se dividen en:

\begin{itemize} 
    \item \textit{Down}: Una tecla esta siendo pulsada. 
    \item \textit{Up}: Una tecla esta soltada. 
    \item \textit{Pressed}: Una tecla acaba de ser pulsada. 
    \item \textit{Released}: Una tecla acaba de ser soltada. 
\end{itemize}  

Algo a tener en cuenta es que debido a la posibilidad de tener varios mandos conectados, el manager diferencia entre métodos
con identificador y métodos sin identificador. Los métodos con identificador reciben el identificador del mando del que se quiere consultar el estado y los métodos sin identificador
devuelven la información del estado del último mando que registró input. De esa manera, si se quiere desarrollar un juego monojugador, el usuario no tendrá que preocuparse por la posibilidad
de múltiples mandos teniendo que indicar que identificador tiene su mando. 

\medskip

Además, el manager tiene soporte para conexiones y desconexiones durante la ejecución, e implementa métodos con lógica usada frecuentemente como lo es el movimiento horizontal para facilitar su implementación al usuario. 




% ----------------------------------------------- FISICAS -------------------------------------------------

\subsection{Físicas}

Este proyecto tiene como objetivo implementar un envoltorio sobre la librería de físicas Box2D \cite{Box2DBook} para proporcionar una API sencilla para el usuario y para desarrollar los componentes de colisión
y movimiento físico necesarios \cite{PhysicsForGameDevelopers}.

\medskip

La física esta representada en un ``mundo físico'' donde se pueden crear cuerpos afectados por la física. La simulación de este mundo tiene la peculiaridad de que se actualiza por intervalos de tiempo fijos, lo que se conoce como ``paso físico''. En estos ``pasos físicos'' se realizan cálculos de colisiones, se resuelven restricciones y se actualizan las posiciones y velocidades de los cuerpos. Además, para evitar que todos los cuerpos
colisiones con todos, existen las capas de colisión. Cada cuerpo se encuentra en una capa y se puede configurar que capas colisionan con que otras.

\medskip

Las clases que tiene este proyecto son las siguientes:

\begin{itemize}
    \item \texttt{PhysicsManager}: Clase, \texttt{Singleton}, que contiene la funcionalidad necesariara para manejar el filtrado de colisiones e información sobre gravedad del mundo físico. 

    \item \texttt{DebugDraw}: Clase que contiene la funcionalidad para dibujar los cuerpos físicos de Box2D. En concreto, puede dibujar polígonos, círculos, segmentos y puntos.
\end{itemize}




% ----------------------------------------------- RENDERER -------------------------------------------------

\subsection{Renderer}

Este proyecto es el que se encarga de mostrar los sprites y fuentes en pantalla, así como limpiar la pantalla o guardar información sobre ella. Hace uso de las librería de SDL, SDL\_Image y SDL\_TTF \cite{SDLGameDevelopment}.

\medskip

Las clases que se encargan de estas funciones son:

\begin{itemize}
    \item \textit{RendererManager}: Clase, \texttt{Singleton}, encargada de inicializar y cerrar la librería de SDL, SDL\_Image y SDL\_TTF. Contiene información y funcionalidad relacionada con la ventana como su
    tamaño, borde, icono, cursor, nombre y modo pantalla completa. Además, proporciona los métodos para renderizar y para limpiar la pantalla.

    \item \textit{Font}: Representa una fuente de texto y tiene la funcionalidad de crear una a partir de una fichero con \textit{'.ttf'} como extensión. Tiene también la funcionalidad de crear un texto o un
    texto ajustado mediante la creación de una textura.

    \item \textit{Texture}: Representa una textura y tiene la funcionalidad de crear una a partir de un fichero con una extensión de imagen como \textit{'.png'} o \textit{'.jpg'}.
\end{itemize}




% ----------------------------------------------- ENTITY COMPONENT ARCHITECTURE -------------------------------------------------

\subsection{Arquitectura de gameplay}
\label{managersycomponentes}

Como arquitectura de gameplay se ha implementado de tipo entidades y componentes (EC) descrito en \ref{ecsystem}.

\medskip

Este es el proyecto implementa la arquitectura, componentes fundamentales para el usuario y una serie de managers como el de escenas, prefabs, referencias y overlay.

\medskip

La partes fundamentales de esta arquitectura son las siguientes: 

\begin{itemize}
    \item \textit{Component}: Clase que representa a un componente. Desde un componente se puede acceder a la entidad y escena que lo contiene y establecer su estado, es decir, activarlo o desactivarlo y eliminarlo. Además, contiene una serie de métodos virtuales preparados para ser implementados por los componentes que hereden de esta clase.

    \item \textit{Entity}: clase que representa una entidad. Contiene una referencia a la escena en la que se encuentra, una lista de componentes y otra de scripts asociados a esta entidad. Tiene información 
    sobre el nombre de la entidad, su estado, un identificador y su orden de renderizado.

    \item \textit{Scene}: La última pieza que compone esta arquitectura son las escenas. Una escena es un conjunto de entidades. Es un concepto importante en los videojuegos ya que normalmente se quiere dividir
    el juego en estados como menús, gameplay, inventario, pantallas de carga, mapa, etc. Contiene información sobre su nombre y bastantes métodos comunes a las entidades y componentes.
\end{itemize}

Como hemos dicho anteriormente, las entidades funcionan como contenedores y los que realmente implementan la funcionalidad son los componentes. Las entidades tienen métodos para añadir componentes, consultar si contienen un componente y eliminarlos.

\subsubsection{Managers y componentes}

Por otro lado, en este proyecto se implementan también los managers necesarios para el funcionamiento del motor y los componentes fundamentales que el motor va a proporcionar al usuario.

\medskip

En cuanto a los componentes:

\begin{itemize}

    \item \textit{Transform}: Contiene la información sobre la posición, rotación y escala de la entidad. Además implementa algunos métodos para rotar, escalar y mover la entidad.

    \item \textit{Overlay}: Componente encargado de representar los elementos de la interfaz de usuario como textos, imágenes y botones.

    \item \textit{Image}: Componente encargado de cargar una imagen y renderizarla en pantalla en la posición indicada por el Transform de la entidad. Para cargar la imagen hace uso del manager de recursos para
    reutilizar la imagen en caso de estar ya creada por otra entidad. 

    \item \textit{PhysicBody}: Componente encargado de crear un cuerpo físico de Box2D. Implementa la funcionalidad de sincronizar posición, rotación y escala del Transform de la entidad al cuerpo físico.
    Contiene la información sobre bastantes propiedades físicas como el tipo de cuerpo (estático, cinemático, dinámico), el rozamiento o la escala de la gravedad.

    \item \textit{SoundEmitter}: Componente encargado de cargar un sonido e implementar métodos para reproducirlo, detenerlo, pausarlo, etc. Como se comentó anteriomente, SDL\_Mixer dispone de un conjunto de canales
    para reproducir sonidos pero este componente es abstrae la necesidad de canales desde la perspectiva del usuario. 

    \item \textit{MusicEmitter}: Componente encargado de cargar música e implementar métodos para reproducirla, detenerla, pausarla, rebobinarla, etc.

    \item \textit{ParticleSystem}: Componente encargado de implementar un sistema de partículas configurable. Tiene soporte para usar texturas para las partículas y moverlas con el motor de físicas Box2D.

    \item \textit{Animation}: Componente encargado de implementar la lógica de reproducción de animaciones.

    \item \textit{TopDownController}: Componente encargado de implementar un movimiento tipo Top-Down. 

    \item \textit{PlatformController}: Componente encargado de implmentar un movimiento de tipo plataformas.

    Estos dos útlimos componentes no son fundamentales ya que son de gameplay, pero aportan comodidad porque evitan al usuario tener que implementarlos usando el sistema de scripting.

    \medskip 

    Mencionar también que es obligatorio que las entidades tengan al menos un componente, Transform u Overlay. Esto es así para poder posicionarlas en pantalla, aunque cambie la manera de dibujarlas.

\end{itemize}

En cuanto a los managers:

\begin{itemize}
    \item \textit{SceneManager}: encargado de manejar las escenas. Para ello, cuenta con una pila en la que va almacenando las escenas que se crean. La escena que se va actualizar en el juego es la que se encuentra
    en el top de la pila. 

    \medskip
    
    Hay 5 operaciones que se pueden realizar:

    \begin{enumerate}
        \item \textit{Operación PUSH}: carga la escena y la añade al top de la pila.

        \item \textit{Operación POP}: elimina la escena en el top de la pila y avisa, a la escena por debajo del top, si la hay, que va a empezar
        a actualizarse.

        \item \textit{Operación POPANDPUSH}: realiza una operación \texttt{POP} y posteriormente una operación \texttt{PUSH}.

        \item \textit{Operación CLEARANDPUSH}: vacia la pila de escenas y añade una nueva al top de la pila que va a empezar a actualizarse.

        \item \textit{Operación CLEAR}: vacia la pila de escenas.
    \end{enumerate}

    \item \textit{SceneLoader}: Clase encargado de leer la información de la escenas creadas en el editor. A la hora de construir la entidades diferencia entre entidades con \texttt{Transform} y entidades
    con \texttt{Overlay}.

    \item \textit{PrefabsManager}: Encargado de cargar la información de los prefabs creados en el editor e implementar métodos para instanciar entidades a partir de la información de esos prefabs. Se 
    diferencia entre prefabs con \texttt{Transform} y prefabs con \texttt{Overlay}. 

    \item \textit{RenderManager}: Encargado de renderizar por orden las entidades de la escena. A la hora de desarrollar el juego es deseable poder elegir el orden en el que se renderizan las 
    entidades. Esto también se conoce como profundidad o z-order.

    \item \textit{ReferencesManager}: Encargado de manejar una relación entre las entidades y sus identificadores. Necesario para evitar problemas al acceder a la referencia de una entidad, por ejemplo en caso de que la referencia sea errónea o dicha entidad haya sido eliminada.
\end{itemize}




% ----------------------------------------------- PROYECTO PRINCIPAL -------------------------------------------------

\subsection{Bucle principal}

\begin{figure}[h]
    \centering
        \includegraphics[width=5cm]{Imagenes/Vectorial/EstructuraBuclePrincipal}
    \caption{Estructura del bucle principal del motor.
        \label{fig:bucleprincipal}}
\end{figure}

Este proyecto implementa la clase \texttt{Engine}, encargada de inicializar el motor, ejecutar su bucle principal y cerrarlo una vez terminado.

\medskip

La figura \ref{fig:bucleprincipal} muestra un diagrama con estructura del bucle principal de ejecución del motor.

\medskip


Además de esos métodos, se realizan cálculos de tiempo para proporcionar al usuario el \texttt{DeltaTime}, el tiempo transcurrido desde el inicio de la ejecución del programa o el número de frames/actualizaciones
hasta el momento. El \texttt{DeltaTime} es una medida de tiempo, generalmente en milisegundos, que informa sobre el tiempo transcurrido entre la iteración anterior y la actual. 

\medskip

Algo a comentar es la diferencia entre el ``paso físico'' y la ``actualización''. La librería de físicas Box2D requiere que la actualización del mundo físico se realice en intervalos
de tiempo fijo, principalmente por motivos de estabilidad. Por ello, es necesario hacer cálculos adicionales para saber en que momentos se debe ejecutar el ``paso físico'' ya que no se puede llamar en cada frame, a 
diferencia de la ``actualización''.

\medskip

La potencia del hardware de la computadora y la carga de trabajo afectan directamente al número de actualizaciones por segundo que se producen en el bucle principal de un videojuego. Por lo tanto, la llamada al 
método ``actualización'' se puede dar con mucha irregularidad. Sin embargo, el motor de física necesita intervalos de tiempo fijo.

\begin{figure}[h]
    \centering
        \includegraphics[width=12cm]{Imagenes/Vectorial/UpdateVsFixed}
    \caption{Diferencia entre la Actualización y el Paso físico.
        \label{fig:updatevsfixed}}
\end{figure}

\medskip

Esto se explica mejor con el diagrama que se muestra en la figura \ref{fig:updatevsfixed}:

Como se puede apreciar, el \texttt{Paso físico}, marcado en verde, siempre se ejecuta en el mismo intervalo de tiempo. Ese intervalo de tiempo fijo es un valor que se puede modificar en el motor en base a las necesidades del videojuego.


\section{Cómo se serializa la información del motor}


La lógica del juego funciona mediante la lectura de datos, los cuales tienen como función representar escenas y scripts. Analizando la forma en la que se carga una escena, lo que ocurre es que se crearán todas las entidades que la habiten, y a cada entidad se le añadirán sus componentes asignados. Por lo que en función de lo que se lea del fichero, el motor tiene que disponer de funcionalidad para identificar el tipo del componente para poder crearlo. Por ejemplo, a partir de una cadena de texto \"Image\" el motor tiene que identificar que se trata del componente \textit{Image} para poder crearlo. Además, las escenas cuentan con información relacionada con los atributos de los componentes de cada entidad, como puede ser la posición de la entidad para el componente \textit{Transform}. Esta información está representada mediante una pareja de valores, ambos mediante cadenas de texto, usados para almacenar tanto el nombre del atributo como el valor que se le quiere dar. En el caso de la lectura de los scripts ocurre algo similar, pero en vez de tener que acceder a los atributos de los componentes, el motor tiene que ser capaz de invocar un método del componente dado conociendo únicamente su nombre.

\medskip

Para solucionar estas situaciones, una posible solución sería implementar en el motor estructuras de datos mediante mapas. La idea es  que estos mpasa nos permitan tanto crear componentes usando su nombre como clave, como acceder a punteros de los atributos de los componentes para poder modificarlos y también nos permita almacenar los punteros a los métodos de los componentes.
Esta implementación mediante mapas tiene dos principales inconvenientes, el primero es la necesidad de tener que abstraer la información almacenada, de forma que en la misma estructura se puedan almacenar datos de diferente tipo. En el caso de la creación de componentes se puede solucionar mediante el uso de herencia y polimorfismo, pero en el caso de los atributos y métodos no resulta tan sencillo pues por ejemplo C++ no permite almacenar en la misma estructura punteros a métodos si pertencen a distintas clases (aunque ambas hereden de una clase común). El otro inconveniente sería el enorme trabajo que supone no solo el tener que programar todas la estructuras sino también el mantenerlas actualizadas cuando según se vaya añadiendo funcionalidad al motor.

\medskip

En lenguajes de programación de alto nivel este problema tiene una fácil solución, y es mediante el uso de reflexión. La reflexión es la capacidad de dotar a un lenguaje con introspección, pudiendo conocer la estructura o incluso modificarla en tiempo de ejecución. En cualquier caso, esta solución no es aplicable a nuestro motor pues ha sido desarrollado C++, lenguaje el cual no tiene soporte para reflexión.

\medskip

Para solventar esta carencia del lenguaje, el motor cuenta con un proyecto adicional llamado \texttt{ECSReader}. 
Este proyecto tiene la función de entender la estructura de componentes para más adelante poder serializar esta información. 
Se trata de una herramienta interna del motor usada para acelerar nuestro desarrollo, la cual no tiene utilidad durante la ejecución del mismo, y debe ser ejecutada al modificar la funcionalidad pública del motor. 

\medskip

Podemos dividir el ciclo de vida de la ejecución de este programa en dos fases: la lectura de los datos del motor y en la generación de nuevos recursos.

\subsection{Lectura del motor}

El programa comienza leyendo el código fuente del motor, leyendo cada fichero y obteniendo de éste la información que considere necesaria. No es necesario almacenar toda la información de todas las clases que se encuentren, por ello antes de guardar los datos pasan por un proceso de filtrado, descrito a continuación.

\begin{itemize}

    \item Almacena en una lista el nombre de todas las clases que hereden de componente, o que por el contrario hereden de uno como ocurren en el caso los componentes físicos.
    \item Para qué atributos de un componente deben guardarse se utiliza una etiqueta especial, \texttt{reflect}. Esta marca debe aparecer delante de cada atributo que se quiera poder serializar. De cada atributo se guarda tanto el nombre como el tipo del mismo.
    \item Para el proceso de almacenar los métodos de un componente se utiliza otra etiqueta nueva, \texttt{publish}. Esta marca funciona como un nuevo modificador de acceso, de forma que todos los métodos que se encuentren entre dicha marca y la siguiente pasarán a ser almacenados. De los métodos se almacena tanto el nombre, como un vector con la entrada (almacenando tanto tipo como nombre) y el valor de salida.

\end{itemize}

Este uso de las etiquetas nos proporciona una gran comodidad y control en el desarrollo del motor, permitiéndonos controlar qué partes del motor queremos que sean expuestas. El motivo de la diferencia de uso de ambas etiquetas es para favorecer la encapsulación, pues en muchos componentes no queremos que haya atributos marcados como públicos pero sí queremos que se puedan modificar desde el editor, cosa que no es cierta en el caso de los métodos, pues toda esa funcionalidad debe ser pública para que el correcto funcionamiento del motor.

\subsection{Recursos generados}
\label{generacionDeDatos}

Una vez todos los ficheros dados son leídos, comienza el proceso de generación de recursos. La función de estos recursos es de vital importancia para la comunicación del motor con el editor. A continuación se menciona cada fichero generado junto con su utilidad.

\begin{enumerate}
    \item \textit{FunctionManager\label{recursosgenerados}}: Este fichero genera una función asociada a cada método que se haya leído, con la diferencia de que en el caso de que se trate de un método de un componente (en lugar de una método de un manager), se añade un parámetro adicional para acceder al puntero del componente. 
    Esta nueva función tiene como salida una estructura abstracta, la cual puede tomar cualquier valor que queramos que sea soportado por el scripting. La función toma como entrada un vector con esta misma estructura abstracta. 
    En la ejecución de la función se comprueba que la entrada dada sea correcta, y en ese caso hace una llamada al método asociado. Además, este fichero genera un mapa que contiene todas las funciones generadas, con su nombre como clave.\\
    
    Con este fichero podemos invocar a la funcionalidad del motor conociendo únicamente el nombre de cada método, lo cual es útil para el intérprete del lenguaje de scripting. Por otro lado, el hecho de haber convertido cada método en funciones, y todas con la misma estructura nos permite poder agrupar todas las funciones en un único mapa.
    

    \item  \textit{ClassReflection}:Esta clase se encarga de manipular los atributos de cada componente, simulando el uso de  reflexión. Con esta clase se puede modificar cada atributo conociendo únicamente su nombre, lo cual es importante durante el proceso de deserialización de una escena.
    
    \item  \textit{ComponentFactory}: Esta clase tiene la función de generar un componente de un tipo determinado dado el nombre del tipo, funcionando a modo de factoría, siendo de vital importancia para el proceso de deserialización de una escena.

    \item  \textit{Ficheros para el editor}: Se generan dos ficheros, uno para componentes y otro para managers, ambos en formato JSON.\@ Estos contienen toda la información relacionada con cada componente y manager, y se trata de los ficheros utilizados para la lectura de los datos del motor en el editor.

\end{enumerate}

Si bien estos ficheros podrían ser generados a mano, esta automatización supone un enorme ahorro de tiempo para el desarrollador. 


\section{Funcionamiento del lenguaje de scripting}

Este lenguaje se trata de un sistema basado en nodos pensando principalmente para ser usado de forma visual, inspirado en el 
sistema de Blueprints de Unreal. Para entender el lenguaje conviene primero entender el concepto de nodo. Un nodo es una agrupación lógica con una función determinada, pudiendo utilizarse para represetar un dato, ejecutar operaciones aritméticas o llamar a funcionalidad dentro del motor. Estos nodos pueden conectarse entre sí, de forma que un nodo que represente una función se le pueda pasar como parámetros de entrada otros nodos. En los casos de nodos que representen funciones, dependiendo de su funcionalidad puede tener también un valor de salida, pudiendo enlazar la salida de una función con la entrada de otra, de esta forma creando comportamientos más complejos.

\medskip 

La ejecución del lenguaje funciona siguiendo un flujo, es decir, poder establecer el orden en el que se ejecutan los nodos, garantizando que el script se comporte siempre de la misma forma, lo cual es importante para casos donde tenemos varias funciones que queremos que se ejecuten de forma secuencial, sin una dependencia directa entre sus valores de entrada y salida.
Este lenguaje de scripting está pensado para funcionar mendiante eventos, como vemos en el apartado \ref{comunicacionScripting}, los cuales son señales enviadas por el motor tras cumplirse una condición, como puede ser en la colisión de dos entidades o la inicialización de la entidad. El lenguaje da soporte para marcar qué nodo queremos ejecutar en respuesta al evento recibido. Estos eventos vienen representados por nodos y funcionan como punto de partida inicial para la ejecución del script.

\medskip 


\begin{figure}[h]
    \centering
        \includegraphics[width=0.5\textwidth]{Imagenes/Vectorial/OrdenNodos}
    \caption{Orden de ejecución de nodos de un script. El número situado junto a cada nodo es el orden en el que se ejecutaría.
        \label{fig:cap4:OrdenNodos}}
\end{figure}


\medskip 


La ejecución de un script sigue la siguiente estructura. Primero se ejecuta el nodo inicial marcado por el evento, y antes de procesar dicho nodo se ejecutan cada una de sus entradas. A su vez, estas entradas siguen el mismo proceso ejecutando primero sus nodos de entrada correspondientes hasta dar 
con un nodo que no tenga entrada. Cuando todas las entradas y sub-entradas han sido procesadas es entonces cuando se ejecuta el propio nodo, el cual pasará el flujo al nodo siguiente. Este proceso se repite hasta dar con un nodo que no tenga ningún nodo siguiente. Durante este proceso un mismo nodo no puede
ser ejecutado dos veces (con la excepción de bucles), y el valor de salida de cada nodo debe ser guardado hasta que termine todo el proceso de ejecución. De esta forma se consigue optimizar la velocidad del lenguaje pues se reduce el número de nodos que son ejecutados, además de mejorar su legibilidad y previsibilidad (por ejemplo en un caso
donde un nodo genere un número aleatorio, poder usar el mismo número con cada acceso al nodo), al precio de no permitir hacer programas que funcionen de forma recursiva.

\medskip

Puede parecer poco intuitivo que el nodo que queremos ejecutar al principio sea el último en ejecutarse, por lo que para facilitar su entendimiento haremos uso de un ejemplo. Supongamos que queremos hacer un programa que escriba por consola el resultado de una suma en cada iteración. Para ello usaremos una estructura similar a la figura \ref{fig:cap4:OrdenNodos} descartando el cuarto nodo. Nuestro nodo inicial sería el nodo encargado de escribir por consola, y aunque sea el nodo directamente enlazado al evento, no se puede ejecutar inmediatamente pues para ello aún hay que procesar el resultado de la suma, la cual a su vez, primero tiene que procesar los dos valores que se quieran sumar. No se puede procesar un nodo sin haber procesado su entrada anteriormente, por ello, 


\medskip

Existen tres tipos de nodos principales: 

\begin{enumerate}


    \item  \textit{Nodo de función}: Este nodo representa una función en el lenguaje, y puede tener entrada y un valor de salida, al igual que puede recibir y pasar el flujo del script. Este nodo puede ser serializado para ser llamado desde otro script, creando así algo semejante a un método en un lenguaje convencional.
    \item  \textit{Nodo de entrada}: Proporciona un valor constante que puede ser usado como entrada para una función. Este valor puede ser serializado para modificarse desde fuera permitiendo reutilizar scripts con datos diferentes. Por ejemplo, un script que represente la vida de un enemigo, y queramos serializar la vida, de forma que con el uso del mismo script, podamos representar enemigos con número de vidas diferentes. Este tipo de nodo no puede recibir el flujo.
    \item  \textit{Nodo de bifurcación}: Este tipo de nodo permite la modificación del flujo del script, pudiendo hacerlo mediante lógica condicional y bucles, su comportamiento dependiendo de su tipo interno. Recibe un valor de entrada a modo de condición y no tiene un valor de salida. En el caso de los bucles, los nodos que se ejecuten dentro del bucle sí que pueden ser ejecutados varias veces en la misma iteración del evento.

\end{enumerate}

Todo esto permite al usuario crear comportamientos complejos de una manera visual sin tener que escribir ninguna línea de código.


\section{Integración scripting en el motor}

Para la integración del lenguaje en el motor aparece \texttt{Script}, un nuevo tipo de componente, junto con un nuevo manager, \texttt{ScriptManager}. Entre estas dos clases se establece el puente entre el motor y el funcionamiento del scripting. \texttt{ScriptManager} funciona tanto como un manejador de recursos de tipo script, de forma
que no se generen copias innecesarias del recurso cuando el script sea reutilizado por otra entidad, al igual que se encarga de su correcta deserialización del formato JSON. Además, también aporta funcionalidad básica para el correcto funcionamiento del scripting. Por otro lado, la clase \texttt{Script} proporciona los eventos necesarios al lenguaje de scripting, redirigiendo los eventos recibidos de la clase componente, además de guardar información adicional 
para almacenar los distintos valores serializados. La clase \texttt{Script} no maneja los nodos, sino que almacena punteros al nodo inicial de cada evento, en caso de que exista.


\medskip


Para la implementación de la lógica del scripting, se ha creado una clase por cada tipo de nodo, siendo responsable cada uno de manejar su propia información, y entre todos creando una jerarquía de clases para poder manejar el script mediante herencia y polimorfismo. Estas clases sirven para representar internamente un script.

\begin{figure}[h]
    \centering
        \includegraphics[width=1.1\textwidth]{Imagenes/Vectorial/DiagramaNodos}
    \caption{Diagrama UML con la estructura de clases de los nodos del scriting
       \label{fig:cap4:DiagramaNodos}}
\end{figure}

\medskip

Para representar los valores dentro del motor, manejamos la abstracción
de una variable la cual puede tomar cualquier valor, y todo se procesa dentro
de una unión (siendo una unión un tipo especial de clase en C++ que solo
puede almacenar el valor de uno de sus miembros). 
El lenguaje está preparado para soportar los tipos: float, char, string, bool, un vector bidimensional de float, una estructura para representar un color y un puntero a una entidad.
Con el fin de simplificar el uso, hemos decidido no distinguir entre tipos númericos (como pueden ser el int o el float) sino manejar una agrupación de ellos, algo parecido al funcionamiento de Javascript\footnotemark.

\medskip

Con el mismo fin de simplificar las cosas, también hemos decidido descartar la capacidad de almacenar un variable de tipo \texttt{Component}. Por ello, en las llamadas a funciones donde hiciera falta un parámetro de tipo \texttt{Componente}, se pasará de tipo entidad, desde la cual se accederá al componente necesario. 

\medskip

Para el tipo entidad hay dos casos de uso. El primer caso ocurre cuando el puntero se consigue en tiempo de ejecución (por ejemplo al acceder al padre de la entidad actual o acceder a la entidad con la que se ha colisionado), en cuyo caso no se requeriría de ningún paso adicional para su uso, pero en el otro caso, la referencia a esta entidad se consigue desde el proceso de deserialización de la escena, donde al no poder guardar directamente un puntero se guarda el identificador de la entidad. Haciendo uso de este identificador y de \textit{ReferencesManager}(sección~\ref{managersycomponentes}:~Managers~y~componentes) se puede acceder al puntero correspondiente.

 \medskip

Para la ejecución de un nodo función, éste almacena el nombre de la función a ejecutar, con lo que se puede ejecutar la función asociada haciendo uso del \textit{FunctionManager}[\ref{recursosgenerados}]. 

\medskip

Por último, para completar el lenguaje se ha creado la clase \textit{ScriptFunctionality}. Esta clase forma parte del motor y se encarga de proporcionar funcionalidad básica que no es aportada por ningún componente, como operaciones aritméticas o escribir por consola.

\footnotetext{\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number}}