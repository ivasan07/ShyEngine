%---------------------------------------------------------------------
%
%                          Motor
%
%---------------------------------------------------------------------

\chapter{Motor}

\section{Funcionamiento y partes del motor}

El motor esta dividido en diez partes fundamentales. A continuación se entrará en detalle sobre la función y detalles de implementación de cada una y de las librerías utilizadas.

Como introducción, en la figura \ref{fig:arquitecturaMotor} se muestra una diagrama resumido sobre la arquitectura del motor.

\begin{figure}[h]
    \centering
        \includegraphics[width=13cm]{Imagenes/Vectorial/ArquitecturaMotor}
    \caption{Arquitectura del motor.
        \label{fig:arquitecturaMotor}}
\end{figure}



% ----------------------------------------------- CONSOLA -------------------------------------------------

\subsection{Consola}

Este proyecto contiene una sola clase Output con métodos estáticos que implementan funcionalidad relacionada con el mostrado de la salida estándar por la consola. Tiene métodos para imprimir texto estándar, advertencias o errores. Estos textos se diferencian por su color y sirven principalmente como ayuda para el desarrollo de un videojuego.



% ----------------------------------------------- UTILIDADES -------------------------------------------------

\subsection{Utilidades}

El objetivo de este proyecto es implementar código común que pueden necesitar el resto  de proyectos evitando así la duplicación de código innecesaria.
Contiene clases tanto orientadas a guardar información como a implementar lógica y funcionalidad.

\medskip

Unos ejemplos de estas clases serían:

\begin{itemize}

    \item \texttt{Vector2D}: Representa un vector bidimensional, contiene información de dos componentes e implementa muchas de sus operaciones básicas. 
    
    \item \texttt{Random}: Contiene métodos estáticos útiles para calcular aleatoriedad entre números enteros, números reales, ángulos, y colores. 
    
    \item \texttt{Color}: Representa un color de tres canales (Red, Green, Blue) además de métodos con algo de funcionalidad como \texttt{Lerp}, que calcula
    un color intermedio entre otros dos dados.
    
    \item \texttt{Singleton}: Una plantilla para crear instancias estáticas a través de herencia. Es decir, en caso de querer convertir una clase en un 
    \texttt{Singleton}, muy útiles para managers, simplemente hay que heredar de esta clase  para conseguirlo. 
    
\end{itemize}



% ----------------------------------------------- RECURSOS -------------------------------------------------

\subsection{Recursos}

El objetivo de este proyecto es proporcionar un contenedor de recursos en el que se van a guardar todos los recursos del videojuego. En concreto, el tipo de
recursos que se pueden guardar son fuentes de texto, imágenes, efectos de sonido y música.

\medskip

Uno de los objetivos del manager de recursos es reutilizar los recursos creados para solo tener cargada una copia de cada recurso en
memoria. Por ello, a la hora de añadir un nuevo recurso al manager, primero comprueba si ya lo contiene y en ese caso, lo devuelve; en caso contrario, lo crea.




% ----------------------------------------------- SONIDO -------------------------------------------------

\subsection{Sonido}

El objetivo de este proyecto es construir un envoltorio sobre la librería de audio \texttt{SDL\_Mixer} para poder implementar posteriormente los componentes de emisión de música y de sonidos.

\medskip

Para un mejor entendimiento de la implementación es necesario saber que \texttt{SDL\_Mixer} diferencia entre efectos de sonido o sonidos cortos en general (WAV, MP3)
y música de fondo (WAV, MP3, OGG).

\medskip

Para la música, la librería solo cuenta con un canal de reproducción por lo que es algo limitado pero simple a la vez ya que no hay que lidiar con el número de canales, 
al contrario que con los efectos de sonido.

\medskip

Este proyecto cuenta con tres clases para representar y manejar sonidos:

\begin{itemize}

\item \texttt{SoundEffect}: Representa un efecto de sonido y contiene un identificador para diferenciado de otro sonidos.

\item \texttt{MusicEffect}: Representa un sonido de música de fondo. Al igual que \texttt{SoundEffect}, contiene un identificador para diferenciarse.

\item \texttt{SoundManager}: Manager \texttt{Singleton} encargado de implementar las funciones principales para reproducir, parar,
y detener sonidos, entre otros. También métodos destinados al usuario para modificar el volumen general y cambiar el número de canales disponibles para la reproducción
de efectos de sonidos.

\end{itemize}



% ----------------------------------------------- INPUT -------------------------------------------------

\subsection{Input}

Este proyecto tiene como objetivo implementar un manager, también \texttt{Singleton}, que contendrá la información del estado de las teclas/botones de los dispositivos de
entrada. En concreto, cuenta con soporte para teclado, ratón y mando.

\medskip

En el manager, las teclas/botones pueden pasar por diferentes estados los cuales se establecen al recibir determinados
eventos.

\medskip

Estos estados se dividen en:

\begin{itemize} 
    \item \textit{Down}: Una tecla esta siendo pulsada. 
    \item \textit{Up}: Una tecla esta soltada. 
    \item \textit{Pressed}: Una tecla acaba de ser pulsada. 
    \item \textit{Released}: Una tecla acaba de ser soltada. 
\end{itemize} 

Algo a tener en cuenta es que debido a la posibilidad de tener varios mandos conectados, el manager diferencia entre métodos
con identificador y métodos sin identificador. Los métodos con identificador reciben el identificador del mando del que se quiere consultar el estado y los métodos sin identificador
devuelven la información del estado del último mando que registró input. De esa manera, si se quiere desarrollar un juego monojugador, el usuario no tendrá que preocuparse por la posibilidad
de múltiples mandos teniendo que indicar que identificador tiene su mando. 

\medskip

Además, el manager tiene soporte para conexiones y desconexiones durante la ejecución, e implementa métodos con lógica usada frecuentemente como lo es el movimiento horizontal para facilitar su implementación al usuario. 




% ----------------------------------------------- FISICAS -------------------------------------------------

\subsection{Físicas}

Este proyecto tiene como objetivo implementar un envoltorio sobre la librería de físicas Box2D \cite{Box2DBook} para proporcionar una API sencilla para el usuario y para desarrollar los componentes de colisión
y movimiento físico necesarios. \cite{PhysicsForGameDevelopers}

\medskip

La física esta representada en un ``mundo físico'' donde se pueden crear cuerpos afectados por la física. La simulación de este mundo tiene la peculiaridad de que se actualiza por intervalos de tiempo fijos, lo que se conoce como ``paso físico''. En estos ``pasos físicos'' se realizan cálculos de colisiones, se resuelven restricciones y se actualizan las posiciones y velocidades de los cuerpos. 

\medskip

Las clases que tiene este proyecto son las siguientes:

\begin{itemize}
    \item \textit{PhysicsManager}: Clase, \texttt{Singleton}, que contiene la funcionalidad necesariara para manejar el filtrado de colisiones e información sobre gravedad del mundo físico. Cada objeto físico tiene información sobre en que capa se encuentra y con que capas colisiona. Para que se produzca una colisión,
    los cuerpos deben cumplir una condición, y es que, la capa del cuerpo A debe de estar marcada para que colisione con la del cuerpo B y viceversa.

    \item \textit{DebugDraw}: Clase que contiene la funcionalidad para dibujar los cuerpos físicos de Box2D. En concreto, puede dibujar polígonos, círculos, segmentos y puntos.
\end{itemize}




% ----------------------------------------------- RENDERER -------------------------------------------------

\subsection{Renderer}

Este proyecto es el que se encarga de mostrar las texturas y fuentes en pantalla, así como limpiar la pantalla o guardar información sobre ella. Hace uso de las librería de SDL, SDL\_Image y SDL\_TTF. \cite{SDLGameDevelopment}

\medskip

Las clases que se encargan de estas funciones son:

\begin{itemize}
    \item \textit{RendererManager}: Clase, \texttt{Singleton}, encargada de inicializar y cerrar la librería de SDL, SDL\_Image y SDL\_TTF. Contiene información y funcionalidad relacionada con la ventana como su
    tamaño, borde, icono, cursor, nombre y modo pantalla completa. Además, proporciona los métodos para renderizar y para limpiar la pantalla.

    \item \textit{Font}: Representa una fuente de texto y tiene la funcionalidad de crear una a partir de una fichero con \textit{'.ttf'} como extensión. Tiene también la funcionalidad de crear un texto o un
    texto ajustado mediante la creación de una textura.

    \item \textit{Texture}: Representa una textura y tiene la funcionalidad de crear una a partir de un fichero con una extensión de imagen como \textit{'.png'} o \textit{'.jpg'}.
\end{itemize}




% ----------------------------------------------- ENTITY COMPONENT ARCHITECTURE -------------------------------------------------

\subsection{Arquitectura de gameplay}

Como arquitectura de gameplay se ha implementado de tipo entidades y componentes (EC) que veíamos en \ref{ecsystem}.

\medskip

Este es el proyecto más importante del motor. Implementa la arquitectura, componentes fundamentales para el usuario y una serie de managers como el de escenas, prefabs, referencias y overlay.

\medskip

La partes fundamentales de esta arquitectura son las siguientes: 

\begin{itemize}
    \item \textit{Component}: Clase que representa a un componente. Contiene una referencia a la entidad a la que está asociado e información sobre si esta activo o eliminado. Desde un componente se puede 
    acceder a la entidad y escena que lo contiene y establecer su estado, es decir, activarlo o desactivarlo y eliminarlo. Además, contiene una serie de métodos virtuales preparados para ser implementados
    por los componentes que hereden de esta clase.

    \item \textit{Entity}: clase que representa una entidad. Contiene una referencia a la escena en la que se encuentra, una lista de componentes y otra de scripts asociados a esta entidad. Tiene información 
    sobre el nombre de la entidad, su estado, un identificador y su orden de renderizado.

    \item \textit{Scene}: La última pieza que compone esta arquitectura son las escenas. Una escena es un conjunto de entidades. Es un concepto importante en los videojuegos ya que normalmente se quiere dividir
    el juego en estados como menús, gameplay, inventario, pantallas de carga, mapa, etc. Contiene información sobre su nombre y bastantes métodos comunes a las entidades y componentes.
\end{itemize}

Como hemos dicho anteriormente, las entidades funcionan como contenedores y los que realmente implementan la funcionalidad son los componentes. Por ello, las entidades únicamente se encarga de mantener 
actualizados a todos los componentes que tengan asociados. Además de los métodos para actualizar a los componentes, las entidades tiene métodos para añadir componentes, consultar si contienen un componente y 
eliminarlos.

\subsubsection{Managers y componentes}
\label{managersycomponentes}

Por otro lado, en este proyecto se implementan también los managers necesarios para el funcionamiento del motor y los componentes fundamentales que el motor va a proporcionar al usuario.

\medskip

En cuanto a los componentes:

\begin{itemize}

    \item \textit{Transform}: Contiene la información sobre la posición, rotación y escala de la entidad. Además implementa algunos métodos para rotar, escalar y mover la entidad.

    \item \textit{Overlay}: Componente encargado de representar los elementos de la interfaz de usuario como textos, imágenes y botones.

    \item \textit{Image}: Componente encargado de cargar una imagen y renderizarla en pantalla en la posición indicada por el transform de la entidad. Para cargar la imagen hace uso del manager de recursos para
    reutilizar la imagen en caso de estar ya creada por otra entidad. 

    \item \textit{PhysicBody}: Componente encargado de crear un cuerpo físico de Box2D. Implementa la funcionalidad de sincronizar posición, rotación y escala del \texttt{Transform} de la entidad al cuerpo físico.
    Contiene la información sobre bastantes propiedades físicas como el tipo de cuerpo (estático, cinemático, dinámico), el rozamiento o la escala de la gravedad.

    \item \textit{SoundEmitter}: Componente encargado de cargar un sonido e implementar métodos para reproducirlo, detenerlo, pausarlo, etc. Como se comentó anteriomente, SDLMixer dispone de un conjunto de canales
    para reproducir sonidos pero este componente es abstrae la necesidad de canales desde la perspectiva del usuario. 

    \item \textit{MusicEmitter}: Componente encargado de cargar música e implementar métodos para reproducirla, detenerla, pausarla, rebobinarla, etc.

    \item \textit{ParticleSystem}: Componente encargado de implementar un sistema de partículas configurable. Tiene soporte para cargar texturas y mover las partículas con el motor de físicas Box2D.

    \item \textit{Animation}: Componente encargado de implementar la lógica de reproducción de animaciones.

    \item \textit{TopDownController}: Componente encargado de implementar un movimiento tipo Top-Down. 

    \item \textit{PlatformController}: Componente encargado de implmentar un movimiento de tipo plataformas.

    Estos dos útlimos componentes no son fundamentales pero aportan comodidad porque evitan al usuario tener que implementarlos usando el sistema de scripting, lo que puede ser algo avanzado.

    \medskip 

    Mencionar también que es obligatorio que las entidades tengan al menos un componente, Transform u Overlay. Esto es así para poder distinguir entre entidades destinadas a la interfaz de usuario y el resto
    de entidades de la escena.

\end{itemize}

En cuanto a los managers:

\begin{itemize}
    \item \textit{SceneManager}: encargado de manejar las escenas. Para ello, cuenta con una pila en la que va almacenando las escenas que se crean. La escena que se va actualizar en el juego es la que se encuentra
    en el top de la pila. 

    \medskip
    
    Hay 5 operaciones que se pueden realizar:

    \begin{enumerate}
        \item \textit{Operación PUSH}: carga la escena y la añade al top de la pila.

        \item \textit{Operación POP}: elimina la escena en el top de la pila y avisa, a la escena por debajo del top, si la hay, que va a empezar
        a actualizarse.

        \item \textit{Operación POPANDPUSH}: realiza una operación \texttt{POP} y posteriormente una operación \texttt{PUSH}.

        \item \textit{Operación CLEARANDPUSH}: vacia la pila de escenas y añade una nueva al top de la pila que va a empezar a actualizarse.

        \item \textit{Operación CLEAR}: vacia la pila de escenas.
    \end{enumerate}

    \item \textit{SceneLoader}: Clase encargado de leer la información de la escenas creadas en el editor. A la hora de construir la entidades diferencia entre entidades con \texttt{Transform} y entidades
    con \texttt{Overlay}.

    \item \textit{PrefabsManager}: Encargado de cargar la información de los prefabs creados en el editor e implementar métodos para instanciar entidades a partir de la información de esos prefabs. Se 
    diferencia entre prefabs con \texttt{Transform} y prefabs con \texttt{Overlay}. 

    \item \textit{RenderManager}: Encargado de renderizar por orden las entidades de la escena. A la hora de desarrollar en juego es deseable poder elegir elegir el orden en el que se renderizan las 
    entidades. Esto también se conoce como profundidad o z-order.

    \item \textit{ReferencesManager\label{referencesManager}}: Encargado de manejar una relación entre las entidades y sus identificadores. Necesario para evitar problemas al accediendo a la referencia de una entidad, por ejemplo en caso de que la referencia sea errónea o dicha entidad haya sido eliminada.
\end{itemize}




% ----------------------------------------------- PROYECTO PRINCIPAL -------------------------------------------------

\subsection{Bucle principal}

Este proyecto implementa la clase \texttt{Engine}, encargada de inicializar el motor, ejecutar su bucle principal y cerrarlo una vez terminado.

\medskip

En cuanto al bucle principal, tiene la siguiente estructura:

\begin{center}
    \includegraphics[scale=0.3]{Imagenes/Vectorial/EstructuraBuclePrincipal}
\end{center}

Además de esos métodos, se realizan cálculos de tiempo para proporcionar al usuario el \texttt{DeltaTime}, tiempo transcurrido desde el inicio de la ejecución del programa o el número de frames/actualizaciones
hasta el momento. El \texttt{DeltaTime} es una medida de tiempo, generalmente en milisegundos, que informa sobre el tiempo transcurrido entre la iteración anterior y la actual. 

\medskip

Algo a comentar es la diferencia entre el \texttt{Paso físico} y la \texttt{Actualización}. La lbrería de físicas Box2D, y todas en general, requieren que la actualización del mundo físico se realice en intervalos
de tiempo fijo, principalmente por motivos de estabilidad. Por ello, es necesario hacer cálculos adicionales para saber en que momentos se debe ejecutar el Paso Físico ya que no se puede llamar en cada frame, a 
diferencia de la \texttt{Actualización}.

\medskip

La potencia del hardware de la computadora y la carga de trabajo afectan directamente al número de actualizaciones por segundo que se producen en el bucle principal de un videojuego. Por lo tanto, la llamada al 
método \texttt{Actualización} se puede dar con mucha irregularidad. Sin embargo, el motor de física necesita intervalos de tiempo fijo.

\medskip

Esto se explica mejor con el siguiente diagrama:

\begin{center}
    \includegraphics[scale=0.3]{Imagenes/Vectorial/UpdateVsFixed}
\end{center}

Como se puede apreciar, el \texttt{Paso físico}, marcado en verde, siempre se ejecuta en el mismo intervalo de tiempo. Ese intervalo de tiempo fijo es un valor que se puede modificar en base a las necesidades
del videojuego.


\section{Cómo se serializa la información del motor}


El motor está hecho en C++, lo cual supone una limitación a la hora del paso información debibo a la carencia de reflexión. La reflexión es la capacidad de dotar a un lenguaje con introspección, pudiendo conocer su propia estructura o incluso modificarla en tiempo de ejecución. 
Esta cualidad es especialmente útil pues permitiría la capacidad de conocer las distintas clases y métodos de los que dispone el motor, así como poder consultar y modificar los atributos de las clases. 

\medskip

Para solventar esta carencia el motor cuenta con un proyecto adicional llamado \texttt{ECSReader}. 
Este proyecto tiene la función de entender la estructura de componentes para más adelante poder serializar esta información. Este proyecto no tiene utilidad durante la ejecución del motor, y se trata de una herramienta que puede ejecutar el desarrollador en cualquier momento que considere oportuno.

\medskip

Podemos dividir el ciclo de vida de la ejecución de este programa en dos fases: la lectura de los datos del motor y en la generación de nuevos recursos.

\subsection{Lectura del motor}

Dadas las rutas con las ubicaciones del código fuente del motor, el programa se encarga de leer cada uno de los ficheros que se encuentren en las rutas dadas. A medida que va leyendo cada fichero, su información se va filtrando y procesando. La información que se guarda 
pertenece a los métodos y atributos de componentes y managers. No es necesario guardar cada método y atributo de cada componente, sólo los que sean de interés, por lo que para poder hacer este filtrado el motor cuenta con dos etiquetas principales: la etiqueta \textit{publish} y la etiqueta \textit{reflect}.
La primera se utiliza como un modificador de acceso en C++, y cada uno de los métodos que se encuentren tras la etiqueta serán los que sean serializados hasta encontrar el siguiente modificador de acceso. La segunda etiqueta está pensada para los atributos, y cada atributo que sea precedido por esa etiqueta son los que serán almacenados.
Este uso de las etiquetas proporciona una gran comodidad y control al desarrollador, permitiéndole controlar qué partes del motor permanecerán expuestas.
Durante la ejecución del \texttt{ECSReader}, se almacena información sobre cada componente, al igual que también se almacena los métodos y atributos requeridos, guardando información como el nombre dado o su tipo. El programa además también tiene en cuenta la herencia de componentes, proporcionando a un componente la funcionalidad de su padre.

\subsection{Recursos generados}
\label{generacionDeDatos}

Una vez todos los ficheros dados son leídos, comienza el proceso de generación de recursos. La función de estos recursos es de vital importancia, tanto para la comunicación del motor con el editor, como para el propio funcionamiento del motor. A continuación se menciona cada fichero generado junto con su utilidad.

\begin{enumerate}
    \item \textit{FunctionManager\label{recursosgenerados}}: Se trata de un par de ficheros en C++, uno siendo el fichero de cabecera y otro de fuente. Entre estos dos ficheros se genera una función para cada método que se haya leído. Además, este fichero cuenta con funcionalidad para agrupar cada una de las funciones en una única estructura, de tal forma que se pueda acceder a cada
    una de las funciones conociéndo únicamente su nombre. Se genera una función para cada método para que de esta forma todas las funciones tengan la misma estructura y además poder hacer manejo de errores antes de redirigir la llamada al método original.

    \item  \textit{ClassReflection}: Se trata de una clase en C++ compuesta por dos ficheros, uno siendo el fichero de cabecera y otro de fuente. Esta clase se encarga de manipular los atributos de cada componente, simulando la reflexión. Con esta clase se puede modificar cada atributo conociendo únicamente su nombre, lo cual es importante durante el proceso de deserialización
    de una escena.
    
    \item  \textit{ComponentFactory}: Se trata de una clase en C++ compuesta por dos ficheros, uno siendo el fichero de cabecera y otro de fuente. Esta clase tiene la función de generar un componente de un tipo determinado dado el nombre del tipo, siendo de vital importancia para el proceso de deserialización de una escena.

    \item  \textit{Ficheros para el editor}: Se generan dos ficheros, uno para componentes y otro para managers, ambos en formato JSON.\@ Estos contienen toda la información relacionada con cada componente y manager, y se trata de los ficheros utilizados para la lectura de los datos del motor en el editor.

\end{enumerate}

Si bien estos ficheros podrían ser generados a mano, esta automatización supone un enorme ahorro de tiempo para el desarrollador. 


\section{Funcionamiento del lenguaje de scripting}

Este lenguaje está pensado para ser utilizado por un editor de programación visual, utilizando flechas y nodos, aunque esto se explicará más en detalle en el apartado del editor \ref{scriptingEditor}.

\medskip 

Este lenguaje de scripting está pensado para funcionar mendiante eventos, como vemos en el apartado \ref{comunicacionScripting}, de forma que se pueda seleccionar qué partes del script queremos ejecutar en respuesta al evento recibido. Estos eventos vienen representados por nodos y funcionan como punto de partida inicial para la ejecución del script.
Esta ejecución funciona siguiendo un flujo, es decir, se establece el orden en el que se ejecutan los nodos, garantizando que el script se comporte siempre de la misma forma. Este flujo vendrá representado por flechas.

\medskip 


\begin{figure}[h]
    \centering
        \includegraphics[width=0.5\textwidth]{Imagenes/Vectorial/OrdenNodos}
    \caption{Orden de ejecución de nodos de un script. El número situado junto a cada nodo es el orden en el que se ejecutaría.
        \label{fig:cap4:OrdenNodos}}
\end{figure}


\medskip 


La ejecución de un script sigue la siguiente estructura. Primero se ejecuta el nodo inicial marcado por el evento, y antes de procesar dicho nodo se ejecutan cada una de sus entradas. A su vez, estas entradas siguen el mismo proceso ejecutando primero sus nodos de entrada correspondientes hasta dar 
con un nodo que no tenga entrada. Cuando todas las entradas y sub-entradas han sido procesadas es entonces cuando se ejecuta el propio nodo, el cual pasará el flujo al nodo siguiente. Este proceso se repite hasta dar con un nodo que no tenga ningún nodo siguiente. Durante este proceso un mismo nodo no puede
ser ejecutado dos veces, y el valor de salida de cada nodo debe ser guardado hasta que termine todo el proceso de ejecución. De esta forma se consigue optimizar la velocidad del lenguaje, reduciendo el número de nodos procesados, además de mejorar su legibilidad y previsibilidad (por ejemeplo en un caso
donde un nodo genere un número aleatorio, poder usar el mismo número con cada acceso al nodo), al precio de no permitir hacer programas que funcionen de forma recursiva.


\medskip

Dependiendo de su funcionamiento existen varios tipos de nodos: 

\begin{enumerate}


    \item  \textit{Nodo de función}: Este nodo representa una función en el lenguaje, y puede tener entrada y un valor de salida, al igual que puede recibir y pasar el flujo del script. Este nodo puede ser serializado para ser llamado desde otro script, creando así algo semejante a un método en un lenguaje convencional.
    \item  \textit{Nodo de entrada}: Proporciona un valor constante que puede ser usado como entrada para una función. Este valor puede ser serializado para modificarse desde fuera permitiendo reutilizar scripts con datos diferentes. Este tipo de nodo no puede recibir el flujo.
    \item  \textit{Nodo de bifurcación}: Permite la implementación de lógica condicional y dos tipos de bucles, dependiendo del tipo interno asociado, haciendo posible modificar el flujo del script durante su ejecución. Recibe además un valor de entrada a modo de condición y no tiene un valor de salida.

\end{enumerate}

Todo esto permite al usuario crear comportamientos complejos de una manera visual sin tener que escribir ninguna línea de código.


\section{Integración scripting en el motor}

Una vez conociendo el lenguaje que ha sido diseñado para el motor, el siguiente punto interesante a tratar es cómo ha sido implementado.
Para su integración en el motor aparece \texttt{Script}, un nuevo tipo de componente, junto con un nuevo manager, \texttt{ScriptManager}. Entre estas dos clases se establece el puente entre el motor y el funcionamiento del scripting. \texttt{ScriptManager} funciona como un manejador de recursos de tipo script de forma
que no se generen copias innecesarias del recurso cuando el script sea reutilizado por otra entidad, al igual que se encarga de su correcta deserialización del formato JSON. Por otro lado, la clase \texttt{Script} proporciona los eventos necesarios al lenguaje de scripting, redirigiendo los eventos recibidos de la clase componente, además de guardar información adicional 
para almacenar los distintos valores serializados. La clase \texttt{Script} no maneja los nodos, sino que almacena punteros al nodo inicial de cada evento, en caso de que exista.


\medskip


Para la implementación de la lógica del scripting, se ha creado una clase por cada tipo de nodo, siendo responsable cada uno de manejar su propia información, y entre todos creando una jerarquía de clases para poder manejar el script mediante herencia y polimorfismo.

\begin{figure}[h]
    \centering
        \includegraphics[width=1.1\textwidth]{Imagenes/Vectorial/DiagramaNodos}
    \caption{Diagrama UML con la estructura de clases de los nodos del scriting
       \label{fig:cap4:DiagramaNodos}}
\end{figure}

\medskip

Para representar los valores dentro del editor, manejamos la abstracción de una variable la cual puede tomar cualquier valor, y todo se procesa dentro de una unión (siendo una unión un tipo especial de clase en C++ que solo puede almacenar el valor de uno de sus miembros). 
El lenguaje está preparado para soportar los tipos: float, char, string, bool, un vector bidimensional de float, una estructura para representar un color y un puntero a una entidad.
Con el fin de simplificar el uso, hemos decidido no distinguir entre tipos númericos (como pueden ser el int o el float) sino manejar una agrupación de ellos, algo parecido al funcionamiento de Javascript\footnotemark.

\medskip

Con el mismo fin de simplificar las cosas, también hemos decidido descartar la capacidad de almacenar un variable de tipo \texttt{Componente}. Por ello, en las llamadas a funciones donde hiciera falta un parámetro de tipo \texttt{Componente}, se pasará de tipo entidad, desde la cual se accederá al componente necesario. 

\medskip

Para el tipo entidad hay dos casos de uso, dependiendo del origen del nodo que haya producido el valor. Si procede de una función, la variable se usa como puntero a la entidad dada, pero si el valor procede de un nodo de entrada, 
 su valor deserializado es el identificador de la entidad. Por lo cual, antes de poder acceder al puntero tenemos que conseguir la referencia a la entidad haciendo uso del \textit{ReferencesManager}[\ref{referencesManager}].

 \medskip

Para la ejecución de un nodo funcion, éste almacena el nombre de la función a ejecutar, con lo que se puede ejecutar la función asociada haciendo uso del \textit{FunctionManager}[\ref{recursosgenerados}]. Cabe mencionar, que en caso de que la función esté asociada a un componente en lugar de un manager, el primer parámetro será siempre un puntero a la entidad.

\medskip

 Por último, para completar el lenguaje se ha creado la clase \textit{ScriptFunctionality}, con funcionalidad básica para poder usar desde el script, como puede ser escribir por consola o realizar operaciones aritméticas.

 \footnotetext{\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number}}