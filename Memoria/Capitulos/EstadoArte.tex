%---------------------------------------------------------------------
%
%                          Estado del arte
%
%---------------------------------------------------------------------

\chapter{Estado del arte}
\label{cap3:estado_del_arte}

\begin{resumen}
Este capítulo se centra en los videojuegos, cómo se desarrollan, qué es un motor de videojuegos, cuáles son sus partes fundamentales, cuáles son los
más utilizados hoy en día y sus características, qué es un editor y porque se usan para el desarrollo, qué significa el scripting y las formas que 
existen para generar comportamiento en los videojuegos.
\end{resumen}

\section{Qué es un videojuego}

Un videojuego es un juego electrónico en el que uno o más jugadores interactúan mediante un controlador con un dispositivo electrónico que muestra
imágenes de video. Este dispositivo, comúnmente conocido como ``plataforma'', puede ser una computadora, una máquina de arcade, una consola de 
videojuegos o teléfono móvil, tableta o una consola de videojuegos portátil.

\medskip

Se puede entender como un programa software que es procesado por una máquina que cuenta con dispositivos de entrada y de salida. El programa contiene 
toda la información, instrucciones, imágenes y audio que componen el videojuego. Va grabado en cartuchos, discos ópticos, discos magnéticos, tarjetas de 
memoria especiales para videojuegos, o bien se descarga directamente a través de Internet.

\medskip

Típicamente, los videojuegos recrean entornos y situaciones virtuales en los que el jugador puede controlar a uno o varios personajes para conseguir
un objetivo dentro de unas reglas determinadas. Dependiendo del videojuego, una partida pueden disputarla una o varias personas contra la máquina o bien
múltiples jugadores a través de una red LAN o en línea vía Internet. El género de un videojuego se refiere a una categoría o clasificación que se utiliza
para describir su estilo, mecánicas de juego, temas y elementos característicos. Algunos de los géneros más representativos son los videojuegos de acción,
rol, estrategia, simulación, deportes o aventura.

\subsection{Cómo se hace un videojuego}

La creación de videojuegos es una actividad llevada a cabo por las empresas desarrolladoras de videojuegos. Estas se encargan de diseñar y programar el videojuego,
desde el concepto inicial hasta el videojuego en su versión final. Esta es una actividad multidisciplinaria, que involucra profesionales de la informática,
el diseño, el sonido, la actuación, etc. El proceso es similar a la creación de software en general, aunque difiere en la gran cantidad de aportes creativos
necesarios. El desarrollo también varía en función de la plataforma objetivo, el género y la forma de visualización (2D, 2.5D y 3D).

\medskip

El modo de desarrollo ha pasado por muchas fases hasta el estado en el que se encuentra en la actualidad. En las primeras décadas a partir del nacimiento de los videojuegos,
los desarrolladores tenían que diseñar hardware específico para ejecutar los juegos. A partir de finales de la década de 1970 en adelante, la mayoría de los juegos se desarrollan
de manera programada, lo que significa que el código y los recursos se crean en computadoras en lugar de hardware dedicado. 

\medskip

La idea fundamental de crear videojuegos se divide en programar el comportamiento, reglas y lógica del juego y crear los recursos (imágenes, audio, mapas, etc) que se
quiera cargar en el juego.

\medskip

Sin entrar mucho en detalle, las etapas que sigue un desarrollo profesional son las siguientes: concepto, diseño, planificación, preproducción, producción, pruebas,
distribución y mantenimiento. Para ello, se suelen utilizar metodologías ágiles de producción para controlar y mejorar el desarrollo  \cite{MetodosAgiles}.


\subsection{Juego dirigido por datos}

El concepto de juego dirigido por datos se refiere a la reutilización de la parte de programación
de un videojuego para hacer otros nuevos a partir de nuevos recursos, también entendidos como datos. Como ejemplos de juegos clásicos dirigidos por datos serían el Quake II y 
el Half-Life, desarrollados por id Software y Valve Corporation, respectivamente.

\medskip

En otras palabras, el motor carga los recursos y cambiando los recursos cambia el juego.

\begin{figure}[t]   
    \centering
    %
    \subfloat[][Quake II (1997)]{
    \includegraphics[width=5cm]{Imagenes/Vectorial/quake2}
    }
    \qquad
    \subfloat[][Half-Life (1998)]{
    \includegraphics[width=5cm]{Imagenes/Vectorial/halflife}
    }
    \caption{Ejemplos de juegos dirigidos por datos con juegos clásicos}
    \label{fig:dirigidosdatos}
\end{figure}  

En todos ellos, se creaban nuevos datos/recursos para desarrollarlos. En la figura \ref{fig:dirigidosdatos} se muestran algunos ejemplos.

\section{Qué es un motor de videojuegos}

Un motor de videojuegos es un entorno de desarrollo que proporciona herramientas para la creación de videojuegos. Su función principal es dotar al videojuego de una bibloteca para
renderizar gráficos 2D y 3D, otra para física que simule las leyes de la física y detección de colisiones, y herramientas para poder crear las animaciones, scripts, sonidos, inteligencia
artificial, redes, gestión de memoria, y demás sistemas del videojuego.

\medskip

El término ``motor de juego'' surgió a mediados de la década de 1990 en referencia a juegos de disparos en primera persona (FPS) como el popular Doom de id Software. Doom fue 
diseñado con una separación razonablemente definida entre sus componentes de software principales (como el sistema de renderizado gráfico tridimensional, el sistema de detección
de colisiones o el sistema de audio) y los recursos artísticos, mundos de juego y reglas de juego que componían la experiencia de juego del jugador. El valor de esta separación
se hizo evidente cuando los desarrolladores comenzaron a licenciar juegos y a adaptarlos para crear nuevos productos mediante la creación de nuevos recursos artísticos, diseños 
de mundos, armas, personajes, vehículos y reglas de juego con cambios mínimos en el software del ``motor''.

\medskip

Hacia finales de la década de 1990, algunos juegos como Quake II y Half-Life fueron diseñados teniendo en cuenta la reutilización y la ``modificación'' de recursos. Los motores se hicieron
altamente personalizables mediante lenguajes de programación de scripts como el Quake C de id Software, y la licencia de motores comenzó a ser una corriente de ingresos secundaria
viable para los desarrolladores que los crearon.

\subsection{División entre motor y gameplay}

El gameplay se define como la experiencia general de jugar a un videojuego. Incluye las mecánicas, las reglas que gobiernan las interacciones entre los elementos en el juego, los
objetivos del jugador, los criterios para ganar o perder, las habilidades del personaje, los NPC (Non-Playable-Characters), y el flujo general de la experiencia de juego en su conjunto 
\cite{GameEngineArchitecture}.

\medskip

La línea entre un juego y su motor a menudo es borrosa. Algunos motores hacen una distinción razonablemente clara, mientras que otros apenas hacen un intento de separar los dos.

\medskip

En la figura \ref{fig:motor-gameplay} se representa lo que es un juego, la caja más grande, y de lo que está compuesto. Por un lado tenemos el gameplay/datos que son los recursos de imágenes, audio,
personajes, modelos, escenas, lógica y comportamiento. Y por otro lado, separado por la línea roja, tenemos el motor, encargado de cargar toda esa información. 

\begin{figure}[t]
    \centering
        \includegraphics[width=10cm]{Imagenes/Vectorial/Motor-Gameplay}
    \caption{División de juego en motor y gameplay.%
        \label{fig:motor-gameplay}}
\end{figure}

\medskip

En realidad aquí surge un problema. Los recursos obvios son imágenes y audio pero el gameplay también tiene mapas donde se colocan los elementos del juego y, sobre todo, comportamiento
que hay que crear y proporcionar al motor. Como veremos más adelante, hay varias formas de conseguir convertir en datos ese comportamiento (que en realidad es programación). 

\medskip

Otro aspecto interesante a comentar es la ``altitud'' a la que se encuentra la línea divisoria entre motor y gameplay. Si la línea está muy alta, entonces el motor nos aporta mucha funcionalidad
y hay que crear poco comportamiento en el gameplay. Eso hace que el motor esté muy focalizado en un tipo de juegos concretos por lo que si el género o tipo del videojuego a desarrollar no es
compatible con el tipo de funcionalidad que aporta el motor se va a terminar excluyendo.

\medskip

De esta forma, es común encontrarse con motores pensados para géneros de videojuegos concretos. Existen motores para desarrollar videojuegos de disparos en primera persona (FPS), videojuegos
de plataformas y en tercera persona, videojuegos de lucha, videojuegos de carreras, videojuegos de estrategia en tiempo real o videojuegos multijugador online masivos, conocidos como (MMOG).

\medskip

Algunos ejemplos de estos motores son Scumm, desarrollado por LucasfilmGames para sus aventuras gráficas, RPG Maker desarrollado por ASCII Corporation para juegos de rol, las primeras versiones
de Frostbite desarrollado por Electronic Arts para juegos de acción y disparos (FPS) o MUGEN desarrollado por Elecbyte para juegos de lucha en dos dimensiones.

\medskip

En el libro Game Engine Architecture \cite{GameEngineArchitecture} se cita lo siguiente: ``Se podría argumentar que una arquitectura orientada a datos es lo que diferencia a un motor de juego
de un software que es un juego, pero no un motor. Cuando un juego contiene lógica o reglas de juego codificadas a mano, o utiliza código de casos especiales para representar tipos específicos
de objetos de juego, se vuelve difícil o imposible reutilizar ese software para crear un juego diferente. Probablemente deberíamos reservar el término motor de juego para el software que es
extensible y puede utilizarse como base para muchos juegos diferentes sin modificaciones importantes.''

\subsection{Partes de un motor de videojuegos}

Como se ha mencionado anteriormente, un motor proporciona la tecnología necesaria para desarrollar un videojuego. Esta tecnología, en realidad, es un conjunto de varías tecnologías con diferentes
propósitos, todos necesarios para el videojuego. Para un motor de carácter general, es decir, sin implementación extra para un tipo de videojuegos concreto, estas tecnologías son las siguientes: 

\begin{itemize}
    \item \textit{Motor de renderizado}: Este componente se encarga de generar los gráficos y la representación visual del juego en la pantalla. Utiliza técnicas de renderizado, como rasterización
    o trazado de rayos, para crear la imagen final. Los motores modernos a menudo admiten efectos visuales avanzados, como sombras dinámicas, iluminación global y efectos de partículas.

    \item \textit{Motor de física}: La física es esencial para dar realismo y coherencia al juego. Este motor simula el movimiento de objetos, colisiones, gravedad y otros efectos físicos. Permite
    que los personajes y objetos del juego interactúen de manera creíble con el entorno y entre sí.

    \item \textit{Motor de audio}: Gestiona la reproducción de efectos de sonido y música en el juego. Puede incluir capacidades de mezcla de audio y efectos especiales para crear una experiencia
    auditiva envolvente.

    \item \textit{Motor de input}: Controla la interacción del usuario con el juego a través de dispositivos de entrada como teclados, ratones, controladores de juegos o pantallas táctiles.

    \item \textit{Motor de animación}: Esto incluye la animación de personajes, la interpolación de movimientos y la gestión de esqueletos o huesos para modelar la anatomía de los personajes.

    \item \textit{Motor de red}: Facilita el juego en línea y la comunicación entre jugadores. Administra la sincronización de datos entre los clientes y el servidor, permite el chat en línea, la
    gestión de partidas y otros aspectos relacionados con la conectividad en línea.

    \item \textit{Gestor de recursos}: Garantiza que todos los posibles recursos del videojuego se carguen y descarguen de manera eficiente en memoria durante la ejecución del juego.

    \item \textit{Subsistemas de soporte}: Sistemas para iniciar y cerrar el motor, manejar la asignación de memoria, sistema de ficheros, etc.
\end{itemize}

\begin{figure}[h]
    \centering
        \includegraphics[scale=0.3]{Imagenes/Vectorial/MotorYGameplay}
    \caption{Partes fundamentales que componen un motor de videojuegos.%
        \label{fig:cap2:motorYGameplay}}
\end{figure}


\section{Arquitectura de videojuegos}

Hasta ahora hemos hablado sobre la idea de motor de videojuegos y lo que los separa del gameplay. Pero a la hora de desarrollar un videojuego existen varios patrones o arquitecturas
que se pueden seguir para construir sus bases. Estas arquitecturas definen el modo de implementar el gameplay y sirven de conexión con el motor. 

\medskip

Un concepto importante para entender el propósito de las arquitecturas son las entidades. Las entidades representan objetos individuales en el juego. Esto podrí­a ser cualquier cosa, 
desde un personaje, un enemigo, un proyectil, hasta un objeto inanimado como una piedra. A día de hoy los videojuegos son un conjunto de entidades que interactuán entre sí y la 
arquitectura usada en el videojuego define como se implementan dichas entidades. 

\medskip

Existen dos tipos de arquitecturas principales \cite{GameEngineArchitecture}:

\begin{itemize}
    \item \textit{Centrada en objetos}: Cada objeto tiene un conjunto de atributos y comportamientos que están encapsulados dentro de la clase (o clases) de la cual el objeto es una 
    instancia. El mundo del juego es simplemente una colección de objetos del juego.

    \item \textit{Centrada en propiedades}: Cada objeto tiene un identificador y un conjunto de propiedades asociadas a ese identificador. El comportamiento de un objeto del juego se 
    define de forma implícita por la colección de propiedades de las que está compuesto.
\end{itemize}

\begin{figure}[t]
    \centering
        \includegraphics[scale=0.3]{Imagenes/Vectorial/ObjetosvsPropiedades}
    \caption{Diferencia entre arquitectura centrada en objetos vs propiedades.%
        \label{fig:objetosvspropiedades}}
\end{figure}

En la figura \ref{fig:objetosvspropiedades} se muestra la diferencia.

\subsection{Arquitectura basada en herencia}

La arquitectura basada en herencia ha sido un enfoque tradicional en el desarrollo de videojuegos y todaví­a se utiliza en algunos motores y sistemas. Este enfoque se centra en la creación de jerarquí­as de clases en las que cada clase representa un tipo de objeto en el juego. Por ejemplo, si está creando un juego de rol (RPG), se podría tener una jerarquí­a de clases que comienza con una clase base ``Personaje'' y se divide en clases derivadas como ``Jugador'' y ``Enemigo''. Cada clase puede agregar o modificar atributos y métodos según sea necesario.

\medskip

La arquitectura basada en herencia presenta ciertas ventajas, especialmente en proyectos pequeños o simples. Una de las ventajas clave es su simplicidad conceptual, ya que la herencia permite establecer relaciones claras entre clases a través de una jerarquía.

\medskip
Sin embargo, esta arquitectura también tiene sus desventajas. Uno de los problemas más significativos es su rigidez. La herencia puede hacer que un sistema sea menos adaptable a cambios o que la creación de nuevas clases sea más complicada, ya que cualquier modificación en la clase base puede afectar a todas las clases derivadas. En proyectos grandes, las jerarquías de clases pueden volverse extremadamente complejas y difíciles de mantener, lo que puede aumentar la complejidad y el tiempo de desarrollo. Además, compartir funcionalidad entre clases no relacionadas en la jerarquía puede ser complicado, lo que dificulta la reutilización de código.

\subsection{Arquitectura basada en entidades y componentes}
\label{ecsystem}

La arquitectura basada en entidades y componentes (EC) es un enfoque fundamental en el desarrollo de videojuegos debido a su flexibilidad y eficiencia en el manejo de la complejidad. Esta basado en la idea de arquitectura centrada en propiedades.

\medskip

En el corazón de la arquitectura EC se encuentran dos conceptos clave:

\begin{itemize}
  \item \textit{Entidades}: Son contenedores vací­os que no contienen lógica ni información por sí­ mismos y lo que les define son sus componentes.

  \item \textit{Componentes}: Los componentes son módulos independientes que contienen datos y lógica. Cada entidad en un juego está compuesta por uno o más componentes que definen sus atributos y comportamiento. Por ejemplo, una entidad de jugador podrí­a tener componentes como ``Posición'' para representar su ubicación en el mundo, ``Imagen'' para la apariencia visual o ``Movimiento'' para el movimiento del personaje, entre otros.

\end{itemize}

La principal ventaja de esta separación entre entidades y componentes es que permite una gran flexibilidad y reutilización de código. Las entidades pueden ser construidas y modificadas dinámicamente combinando diferentes componentes. Esto facilita la creación de nuevos tipos de objetos en el juego sin necesidad de escribir código especí­fico para cada uno.

\section{¿Qué es un editor?}
\label{cap3:sec:motores}

Un editor de videojuegos es una herramienta de software diseñada para facilitar la creación, diseño y modificación de videojuegos. A lo largo de la historia de los videojuegos, los editores han evolucionado significativamente en términos de funcionalidad y usabilidad  \cite{lengyel2010game}.

\subsection{Evolución histórica de los editores}

En sus inicios, los editores de videojuegos eran herramientas rudimentarias que requerían un conocimiento técnico profundo y estaban reservados principalmente para desarrolladores de juegos experimentados. Estos primeros editores solían centrarse en la manipulación de código y la creación de niveles o mapas, con una interfaz de usuario limitada.

\medskip

Con el tiempo, a medida que la industria de los videojuegos creció y se diversificó, los editores se volvieron más accesibles y versátiles. Surgieron soluciones más amigables para el usuario que permitían a diseñadores, artistas y creadores de contenido participar en el proceso de desarrollo de juegos sin necesidad de habilidades de programación avanzadas.

\subsection{Importancia en el desarrollo de videojuegos}

Los editores de videojuegos desempeñan un papel crucial en el proceso de desarrollo de un videojuego. Estas herramientas permiten a los desarrolladores:

\begin{enumerate}
    \item \textit{Diseñar niveles y escenarios}: Los editores permiten la creación y edición de entornos, niveles y escenarios. Los diseñadores pueden colocar objetos, enemigos, obstáculos y elementos interactivos en el mundo del juego.

    \item \textit{Gestionar recursos}: Los editores proporcionan una plataforma para administrar recursos del juego, como imágenes, sonidos, modelos 3D y más. Los recursos se organizan y se pueden vincular a elementos del juego.

    \item \textit{Definir comportamientos}: Los editores modernos permiten definir comportamientos de personajes y objetos mediante sistemas visuales de programación o scripts. Esto facilita la creación de interacciones y mecánicas de juego.

    \item \textit{Simular y depurar}: Los editores a menudo incluyen herramientas de simulación y depuración que ayudan a los desarrolladores a probar y solucionar problemas en tiempo real.
\end{enumerate}

\begin{figure}[t]
    \centering
    \includegraphics[width=13cm]{Imagenes/Vectorial/Worldcraft}
    \caption{Editor de WorldCraft}
    \label{fig:Worldcraft}
\end{figure}
\medskip 

\subsection{Enfoque histórico y actual de la integración entre editor y motor}

En la actualidad, muchos editores de videojuegos vienen con motores integrados, una evolución significativa con respecto a la forma en que solían operar por separado. Antes, los motores y los editores solían ser herramientas independientes, lo que requería a los desarrolladores crear contenido en el editor y luego importarlo y vincularlo manualmente al motor. 

\medskip 

Un ejemplo histórico de esta separación entre motores y editores es el caso de WorldCraft (figura~\ref{fig:Worldcraft}), una herramienta de diseño de niveles utilizada por Valve para desarrollar juegos como ``Half-Life''. En ese entorno, los diseñadores creaban mapas y niveles en WorldCraft, pero luego necesitaban compilar esos niveles en un formato que el motor del juego pudiera entender. Este proceso de compilación a menudo llevaba tiempo y podía ser complicado, lo que requería una comprensión profunda de ambas herramientas.

\medskip

Sin embargo, con la integración de los motores dentro de los editores en la actualidad, este proceso se ha simplificado significativamente. El motor y el editor trabajan en conjunto de manera más fluida, lo que permite a los desarrolladores diseñar niveles, crear contenido y ajustar parámetros directamente en el editor. La comunicación entre el editor y el motor es más directa, lo que significa que los cambios realizados en el editor se reflejan de manera más inmediata en el juego. Por ejemplo, un diseñador puede usar el editor para colocar entidades en el mapa, definir sus atributos y comportamientos, y estos cambios se pueden apreciar de manera inmediata.

\medskip 

Esta integración ha mejorado significativamente la eficiencia y la productividad en el desarrollo de videojuegos, permitiendo a los equipos de desarrollo centrarse más en la creatividad y la iteración rápida.


% --------------------------------------------------------- SCRIPTING -------------------------------


\section{Convertir el comportamiento en datos para el motor}

Una pregunta esencial en el desarrollo de videojuegos es cómo traducir el comportamiento deseado del juego en información que el motor del juego pueda procesar. La manera en que esto se logra depende en gran medida de cómo esté estructurado el motor y que margen de personalizaciçon se quiere proporcionar a los creadores de gameplay.

\medskip 

Si el motor del juego está diseñado para ser muy específico y limitado en cuanto a la personalización, es posible que no sea necesario programar comportamientos adicionales. Por ejemplo, en las expansiones de Los Sims, gran parte del comportamiento ya está incorporado en el motor del juego, y los datos simplemente se utilizan para ajustar y personalizar ese comportamiento existente. En este caso, el diseñador trabaja dentro de las restricciones del motor existente y utiliza los datos para modificar cómo se comportan las entidades del juego.

\medskip 

En contraste, si el motor no está diseñado para ser tan específico y se requiere agregar comportamientos particulares, entonces es necesario recurrir a la programación. Es aquí donde se pueden dar distintos enfoques:

\begin{enumerate}
    \item Un enfoque común en esta situación es el uso de Dynamic Link Libraries o bibliotecas de enlace dinámico. Aquí, los programadores escriben código en lenguajes como C++ para definir nuevos comportamientos o características del juego. Estos comportamientos se agrupan en bibliotecas que se integran con el motor del juego.

    \medskip 

    La clave del funcionamiento de estas bibliotecas es el enlace dinámico. En lugar de incluir todo el código de la biblioteca en el ejecutable del juego, el programa principal solo contiene referencias a las funciones y datos en esta. Estas referencias se resuelven en tiempo de ejecución cuando el juego se carga. Esto significa que el ``.exe'' es independiente de la biblioteca, que se carga como datos y se ejecuta siguiendo el convenio acordado por el motor.  

    \medskip 

    Este enfoque de bibliotecas de enlace dinámico ha sido ampliamente utilizado en motores de juego como Unreal Engine, lo que ha contribuido a su éxito en la  industria del desarrollo de videojuegos. Además, también se empleó en juegos icónicos como Quake II y Half-Life.

    \medskip

    \item Otra alternativa importante es el uso de ``programación no nativa'' mediante el empleo de lenguajes de script. Un ejemplo clásico de esto es el uso de Lua. Lua es un lenguaje de script que se interpreta, lo que significa que para el motor del juego es simplemente un archivo de texto que contiene instrucciones.

    \medskip 

    Este enfoque tiene varias ventajas. Primero, permite iteraciones rápidas en el desarrollo, ya que no es necesario recompilar todo. Además, no se requiere un entorno de desarrollo costoso como Visual Studio para programar el gameplay, lo que reduce los costos y las barreras de entrada para los desarrolladores ya que se ejecuta en máquina virtual aislada y suelen ser lenguajes mas sencillos \cite{de2008lua}.
    
    \medskip 

    Sin embargo, este enfoque también presenta desafíos. Se necesita una conexión efectiva entre el mundo nativo (generalmente escrito en lenguajes como C++) y el lenguaje de script para que puedan comunicarse y llamar funciones entre sí, y la ejecución de un lenguaje interpretado es más lenta.
    
    \medskip 

    A cambio, como todo se maneja como datos, la parte de reflexión se vuelve más sencilla para la serialización y la interacción con el editor del juego. Esto significa que los comportamientos y características definidos en lenguajes de script suelen ser más accesibles y configurables en el editor del juego sin necesidad de recompilar el motor. 
    
\end{enumerate}

Por supuesto, también es importante considerar las limitaciones y desafíos que los lenguajes de script pueden presentar. Aunque son poderosos en muchos aspectos, no son lo suficientemente sencillos como para que los diseñadores puedan esbozar comportamientos de manera rápida. Una opción de mayor simplicidad es la programación visual.

\subsubsection*{Programación visual}
\label{programacionVisual}

La programación visual es una alternativa que busca hacer que la creación de comportamientos y características del juego sea más accesible para los diseñadores. En lugar de escribir líneas de código, los diseñadores pueden utilizar interfaces gráficas y elementos visuales para definir y configurar el comportamiento del juego. Esto hace que el proceso sea más intuitivo y menos dependiente de conocimientos de programación.

\medskip 

En este enfoque, lo que se crea visualmente se traduce aún en datos que el motor del juego puede entender. Estos datos pueden interpretarse de diversas formas. Por ejemplo, se pueden transpilar a código C++, lo que finalmente nos llevaría de nuevo al primer enfoque que mencionamos. También podrían reescribirse en un lenguaje de script como Lua, o simplemente serializarse en un formato propio y luego ejecutarse mediante un intérprete diseñado específicamente para ese formato.


\subsection{Comunicación entre motor y scripting}
\label{comunicacionScripting}

La interacción entre el motor del juego y el sistema de scripting en lo que respecta al gameplay es una consideración central en el proceso de desarrollo de videojuegos en tiempo real. Dado que el motor del juego conoce  los eventos que suceden en el juego, como el fin de una partida o colisiones entre entidades, surge la interrogante de cómo las entidades del juego adquieren conocimiento de estos eventos. En este contexto, se emplean principalmente dos enfoques: el sistema de eventos y el método de encuestas:

\begin{itemize}
    \item \textit{Eventos}: El sistema de eventos podría dividirse en tres partes:
        \begin{enumerate}
            \item \textit{Generación de eventos}: El motor del juego genera eventos cuando ocurren acciones o situaciones relevantes en el juego. Estos eventos pueden ser muy variados y pueden incluir cosas como colisiones entre objetos, la finalización de una partida, la recolección de un objeto, etc.

            \item \textit{Registro de eventos}: Las entidades del juego pueden registrarse para escuchar eventos específicos. Por ejemplo, un personaje podría registrarse para recibir un evento cuando colisiona con un enemigo.

            \item \textit{Manejadores de eventos}: Cuando se produce un evento, el motor del juego busca a todas las entidades registradas que estén interesadas en ese evento particular y llama a los manejadores de eventos correspondientes en esas entidades. Estos manejadores de eventos son funciones que se ejecutan para reaccionar al evento de una manera determinada.
        \end{enumerate}

    \item \textit{Encuestas}: El método de encuestas implica que las entidades del juego consulten activamente el estado del juego y los eventos relevantes en lugar de esperar a ser notificadas de ellos. En este enfoque, cada entidad del juego, de manera periódica o en respuesta a ciertos eventos de tiempo, realiza una encuesta o consulta al estado actual del juego, y reacciona en base a ello.

    Si bien este método puede ser más simple de implementar en algunos casos, puede resultar en un mayor uso de recursos de CPU ya que las entidades deben realizar encuestas continuas, incluso si no hay eventos relevantes en ese momento.

\end{itemize}


% --------------------------------------------------------- EJEMPLOS DE MOTORES -------------------------------

\section{Ejemplos de motores}

\subsection{Unity}
\label{cap:unity}

Unity es ampliamente reconocido como uno de los motores de videojuegos más populares y versátiles en la industria actual, que fue lanzado en 2005 por Unity Technologies. Lo que distingue a Unity es su separación intermedia entre gameplay y motor, que permite desarrollar una amplia variedad de videojuegos, desde simples juegos móviles 2D hasta experiencias de realidad virtual inmersivas para múltiples plataformas, incluyendo PC, consolas y dispositivos móviles \cite{Unity}.

\medskip

En la figura \ref{fig:unityEditor} podemos ver el editor de Unity.

\begin{figure}[t]
    \centering
        \includegraphics[scale=0.23]{Imagenes/Vectorial/UnityEditor}
    \caption{Editor de Unity.%
        \label{fig:unityEditor}}
\end{figure}


\subsubsection{Arquitectura}

En términos de su arquitectura, Unity adopta una estructura que se alinea con la arquitectura basada en entidades y componentes (EC) [\ref{ecsystem}]. En este enfoque, los elementos fundamentales son los \textit{GameObjects}, que funcionan como las entidades en el mundo del juego. Cada \textit{GameObject} puede estar compuesto por una combinación de ``componentes'', que actúan como los módulos responsables de definir su comportamiento y características.

\medskip

La familiaridad con esta arquitectura es evidente desde el propio editor de Unity. El proceso de desarrollo se basa en la creación de entidades (\textit{GameObjects}) y la asignación de scripts (componentes) para otorgar funcionalidad al juego. Estos scripts, escritos en C\#, permiten definir cómo interactúan y responden los \textit{GameObject} en el mundo del juego.

\subsubsection{Scripting}

El sistema de scripting de Unity se basa en C\# y hace uso fundamentalmente del componente \texttt{MonoBehaviour}. \texttt{MonoBehaviour} es una clase de la que todos los scripts en Unity deben heredar para funcionar
como componentes adjuntos a objetos en el juego. Significa que cualquier script destinado a ser un componente en un \textit{GameObject} debe ser una subclase de \texttt{MonoBehaviour}. Esta herencia permite que Unity comprenda
y gestione adecuadamente los scripts como parte integral de la lógica del juego \cite{hecker2015unity}.

\subsection{Unreal Engine}

Unreal Engine es un motor de videojuegos desarrollado por Epic Games. Apareció por primera vez en 1998 con el videojuego de disparos en primera persona Unreal y actualmente se encuentra en la versión 5.3. Está escrito en 
C++ y es multiplataforma. En cuanto a la ``altitud'' de la línea de separación entre motor y gameplay, Unreal Engine ofrece bastante pero no por ello lo convierte en un motor pensado para un tipo de videojuegos concreto. De hecho, aporta tanta funcionalidad que se considera de propósito general. Es tan potente que además de videojuegos, con Unreal se puede hacer simulación, diseño de automóviles, arquitectura, e incluso vídeos y películas \cite{Unreal}.


\medskip 

En cuanto al editor, se muestra en la figura \ref{fig:unrealeditor}:


\subsubsection{Arquitectura}

La arquitectura de gameplay en Unreal Engine es una mezcla de componentes y herencia. El motor utiliza una combinación de herencia de clases y la composición de componentes para crear objetos y personajes en el mundo del juego.

\medskip

En cuanto a la herencia de clases, Unreal Engine utiliza la herencia de clases para crear una jerarquía de objetos y personajes. Por ejemplo, se puede tener una clase base que representa un personaje jugable y luego crear subclases que hereden de la clase base para crear personajes específicos con características adicionales. Esto permite la reutilización de código y la organización de la funcionalidad común.

En Unreal lo correspondiente a los \textit{GameObject} son los \textit{Actor}.

\medskip

Además de la herencia de clases, Unreal Engine hace un uso extensivo de la composición de componentes. Los componentes son módulos independientes que se adjuntan a los actores (objetos y personajes) para proporcionar funcionalidad adicional. Por ejemplo, un personaje jugable puede tener componentes para la cámara, el control de movimiento, la colisión y la animación. Los componentes se pueden agregar y eliminar de manera flexible para personalizar el comportamiento de los actores sin necesidad de crear nuevas clases.

\medskip

Por otra parte, Unreal Engine cuenta con los Blueprints, que permiten definir la lógica y el comportamiento de los actores y componentes de una manera visual y gráfica. Esto significa que se puede definir cómo interactúan los componentes y actores a través de conexiones visuales en lugar de escribir código. Los Blueprints se pueden utilizar tanto para heredar comportamientos como para agregar componentes y personalizarlos.

\begin{figure}[t]
    \centering
        \includegraphics[scale=0.23]{Imagenes/Vectorial/unrealeditor}
    \caption{Editor de Unreal Engine.%
        \label{fig:unrealeditor}}
\end{figure}

\subsubsection{Sistema de scripting}

En cuanto al creación de comportamiento, Unreal Engine tiene dos modos distintos pero compatibles:

\begin{itemize}
    \item \textit{Programación en C++}: Permite a los desarrolladores escribir código en C++ para crear la lógica del juego, personalizar el comportamiento de los actores y desarrollar características específicas. Esta opción es ideal para tareas que requieren un alto rendimiento o una manipulación más detallada de los sistemas del motor. También es cierto que la programación en C++ puede ser más compleja que el uso de Blueprints, especialmente para quienes no están familiarizados con el lenguaje \cite{sherif2016unreal}.

    \item \textit{Blueprints}: Son una herramienta visual que permite a los desarrolladores crear la lógica del juego sin necesidad de programar en C++. Este scripting es de tipo basado en nodos y funciona con la unión de nodos y a través de la creación flujo y lógica. Por ello, se pueden crear prototipos rápidamente y no requieren de conocimientos de programación para utilizarlos \cite{valcasara2015unreal}. En la figura \ref{fig:blueprints} vemos la herramienta Blueprints de Unreal.
\end{itemize}

En cuanto a la combinación de ambos enfoques, Unreal Engine permite integrar fácilmente código C++ y Blueprints en un mismo proyecto. Esto significa que se puede utilizar C++ para las partes críticas del rendimiento o para implementar sistemas complejos, mientras que se utiliza Blueprints para prototipos rápidos, lógica de juego simple y personalización de componentes y actores. Los Blueprints también pueden comunicarse con código C++ a través de interfaces definidas, lo que permite una colaboración eficaz entre programadores y diseñadores.


\begin{figure}[h]
    \centering
        \includegraphics[scale=0.5]{Imagenes/Vectorial/blueprintsUnreal.png}
    \caption{Blueprints de Unreal Engine.}%
    \label{fig:blueprints}
\end{figure}

% \subsubsection{Comunicación motor-editor}

% En este apartado debemos diferenciar de los elementos, escenas, personajes y todo lo que se pueda crear en el editor de Unreal Engine con los Blueprints.

% \medskip

% En el primer caso, la información del editor se almacena en archivos de nivel ``.umap'' que contienen información sobre la ubicación de los elementos, las configuraciones de iluminación, las cámaras y más. Posteriormente, en tiempo de carga, qué sucede antes de la ejecución, Unreal Engine lee el archivo de nivel correspondiente. Este proceso implica cargar recursos desde disco, configurar la jerarquía del nivel y preparar la representación en memoria de los objetos y elementos del nivel.

% \medskip

% En el segundo caso, los Blueprints en Unreal Engine generan código C++. Cuando se ejecuta el juego o la simulación en Unreal Engine, el motor utiliza este código C++ generado a partir de los Blueprints para ejecutar la lógica de juego. Esto significa que el motor puede interpretar y ejecutar los Blueprints de la misma manera que ejecutaría código C++ escrito manualmente.

